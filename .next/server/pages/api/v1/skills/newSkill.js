/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/v1/skills/newSkill";
exports.ids = ["pages/api/v1/skills/newSkill"];
exports.modules = {

/***/ "./pages/api/v1/skills sync recursive":
/*!***********************************!*\
  !*** ./pages/api/v1/skills/ sync ***!
  \***********************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./pages/api/v1/skills sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("axios");

/***/ }),

/***/ "(api)/./pages/api/v1/skills/newSkill.ts":
/*!*****************************************!*\
  !*** ./pages/api/v1/skills/newSkill.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_gpt_gptUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../utils/gpt/gptUtils */ \"(api)/./utils/gpt/gptUtils.ts\");\n/* harmony import */ var _utils_skills_commandUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../utils/skills/commandUtil */ \"(api)/./utils/skills/commandUtil.ts\");\n/* harmony import */ var _utils_notion_notionUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../utils/notion/notionUtils */ \"(api)/./utils/notion/notionUtils.ts\");\n// This is the beginning of this DATA Skill, made at Tuesday, June 11, 2024 at 9:20:42.723 PM MDT by DATA. Here is where it is located in the project file:// api/v1/skills/arcSolver.ts\n\n\n\nconst handler = async (req, res)=>{\n    let { userRequest , phoneNumber , email , model , location , currentUserTime , clipboardCopy , args , returnType , bot  } = req.body;\n    if (returnType === \"skillDef\") {\n        const dataSkillDef = {\n            fileName: \"arcSolver\",\n            displayName: `ARC Solver`,\n            model: `Uses current selection`,\n            recommendedModels: [\n                `gpt-4`,\n                `anthropic-claude`\n            ],\n            emoji: \"\\uD83E\\uDDE9\",\n            headerImage: \"https://i.imgur.com/iu8n6yv.png\",\n            icon: \"https://i.imgur.com/B7bTRNV.png\",\n            description: `## AI-Powered Abstraction and Reasoning Challenge (ARC) Solver ðŸ§©ðŸ’¡\n\nThis skill takes a user-provided ARC task JSON file, analyzes the training pairs to identify transformation patterns, iteratively refines the rules, and applies them to the test pairs to generate step-by-step solutions. It returns a formatted markdown document with the solution steps and explanations.\n\n### Usage\nTo use this skill, provide the file path or URL to a single ARC task JSON file in the following format:\n\n<userRequest>\nPlease solve the ARC task in the file [path/to/task.json]\n</userRequest>\n\nThe skill will load the task file, extract the training and test pairs, analyze the patterns, refine the rules, apply them to generate solutions, and return a detailed markdown solution document.\n\n### Capabilities\n- Handles both local file paths and remote URLs for task JSON files\n- Analyzes training pairs using AI to identify transformation patterns\n- Iteratively refines transformation rules based on training pairs\n- Applies refined rules to test pairs to generate step-by-step solutions\n- Formats solution steps and explanations in a readable markdown document\n- Sends an SMS alert when the solution is ready, with a link to the full document\n\n### Limitations\n- May struggle with highly complex or abstract patterns beyond the training data\n- Solution quality depends on the available training pairs and model performance\n- Large or numerous test pairs may impact performance and generation time\n\n### Prerequisites\nThis skill requires the user to supply a valid JSON file containing an ARC task with training and test pairs. The file should adhere to the expected structure and format.`,\n            reliability: `Reliable on most ARC tasks, but performance may vary for highly complex or abstract patterns.`,\n            reliabilityRatio: 0.8,\n            keywords: [\n                \"ARC\",\n                \"Abstraction and Reasoning Challenge\",\n                \"AI solver\",\n                \"pattern recognition\",\n                \"rule induction\",\n                \"grid transformations\",\n                \"problem solving\",\n                \"logic\",\n                \"reasoning\"\n            ],\n            factChecking: `This skill generates solution steps based on the provided task file. Fact-checking is not explicitly performed, as the skill focuses on discovering patterns and applying transformations rather than verifying external information.`,\n            estimatedRunTime: \"60-120 seconds\",\n            sotaEstimatedCost: \"$2.50\",\n            maxConcurrency: 5,\n            prePrompt: false,\n            dependencies: [],\n            skillClass: \"recursiveSkill\",\n            knownIssues: `- May struggle with highly abstract or complex patterns not well-represented in the training data\n- Solution quality and performance can vary depending on the specific task and model used\n- Extremely large or numerous test pairs may impact generation time and resource usage`,\n            roadmap: `- Enhance pattern recognition and rule induction capabilities to handle more abstract tasks\n- Improve solution explanation clarity and add visualizations for better understanding\n- Optimize performance for larger task sets and more efficient resource usage\n- Integrate additional AI models and techniques for improved accuracy and robustness`,\n            walkthrough: `1. Receive user request with the file path or URL to the ARC task JSON file\n2. Load the task file and parse the training and test pairs\n3. Analyze the training pairs using AI to identify transformation patterns\n4. Generate initial rules based on the identified patterns\n5. Iteratively refine the rules by testing them against the training pairs and updating as needed\n6. Apply the refined rules to the test pairs to generate step-by-step solutions\n7. Format the solution steps and explanations into a readable markdown document\n8. Send an SMS alert to the user with a link to the full solution document\n9. Return the formatted solution document and debug information as the API response`,\n            author: \"Steve Moraco\",\n            authorDUID: \"SteveMoraco-COS-2023-1201-0420-6009\",\n            paypalEmail: \"steve.moraco@gmail.com\",\n            donateLink: \"https://heydata.org\",\n            socialHandle: \"https://twitter.com/SteveMoraco\",\n            promoUrl: \"https://heydata.org\",\n            supportUrl: \"https://heydata.org/chat\",\n            skillDUID: \"ARCSolver-COS-2024-0611-2120-4272\",\n            skillVersion: \"1.0.0\",\n            dataVersion: \"4.2.0\",\n            status: \"published\",\n            createdAt: \"Tuesday, June 11, 2024 at 9:20:42.723 PM MDT\",\n            updatedAt: \"Tuesday, June 11, 2024 at 9:20:42.723 PM MDT\"\n        };\n        res.status(200).json({\n            dataSkillDef\n        });\n        return;\n    }\n    let debug = \"\"; // Initialize debug variable for logging\n    const sourceCode = `\\`\\`\\`\nARC-AGI/\n â”œâ”€â”€ .cache\n â”œâ”€â”€ .git\n â”œâ”€â”€ README.md\n â”œâ”€â”€ apps\n |  â”œâ”€â”€ css\n |  |  â”œâ”€â”€ common.css\n |  |  â”œâ”€â”€ testing_interface.css\n |  â”œâ”€â”€ img\n |  â”œâ”€â”€ js\n |  |  â”œâ”€â”€ common.js\n |  |  â”œâ”€â”€ testing_interface.js\n |  â”œâ”€â”€ testing_interface.html\n â”œâ”€â”€ data\n |  â”œâ”€â”€ evaluation\n |  â””â”€â”€ training\n./README.md\n\n# Abstraction and Reasoning Corpus for Artificial General Intelligence (ARC-AGI)\n\nThis repository contains the ARC-AGI task data, as well as a browser-based interface for humans to try their hand at solving the tasks manually.\n\n*\"ARC can be seen as a general artificial intelligence benchmark, as a program synthesis benchmark, or as a psychometric intelligence test. It is targeted at both humans and artificially intelligent systems that aim at emulating a human-like form of general fluid intelligence.\"*\n\nA complete description of the dataset, its goals, and its underlying logic, can be found in: [On the Measure of Intelligence](https://arxiv.org/abs/1911.01547).\n\nAs a reminder, a test-taker is said to solve a task when, upon seeing the task for the first time, they are able to produce the correct output grid for *all* test inputs in the task (this includes picking the dimensions of the output grid). For each test input, the test-taker is allowed 3 trials (this holds for all test-takers, either humans or AI).\n\n\n## Task file format\n\nThe \\`data\\` directory contains two subdirectories:\n\n- \\`data/training\\`: contains the task files for training (400 tasks). Use these to prototype your algorithm or to train your algorithm to acquire ARC-relevant cognitive priors.\n- \\`data/evaluation\\`: contains the task files for evaluation (400 tasks). Use these to evaluate your final algorithm. To ensure fair evaluation results, do not leak information from the evaluation set into your algorithm (e.g. by looking at the evaluation tasks yourself during development, or by repeatedly modifying an algorithm while using its evaluation score as feedback).\n\nThe tasks are stored in JSON format. Each task JSON file contains a dictionary with two fields:\n\n- \\`\"train\"\\`: demonstration input/output pairs. It is a list of \"pairs\" (typically 3 pairs).\n- \\`\"test\"\\`: test input/output pairs. It is a list of \"pairs\" (typically 1 pair).\n\nA \"pair\" is a dictionary with two fields:\n\n- \\`\"input\"\\`: the input \"grid\" for the pair.\n- \\`\"output\"\\`: the output \"grid\" for the pair.\n\nA \"grid\" is a rectangular matrix (list of lists) of integers between 0 and 9 (inclusive). The smallest possible grid size is 1x1 and the largest is 30x30.\n\nWhen looking at a task, a test-taker has access to inputs & outputs of the demonstration pairs, plus the input(s) of the test pair(s). The goal is to construct the output grid(s) corresponding to the test input grid(s), using 3 trials for each test input. \"Constructing the output grid\" involves picking the height and width of the output grid, then filling each cell in the grid with a symbol (integer between 0 and 9, which are visualized as colors). Only *exact* solutions (all cells match the expected answer) can be said to be correct.\n\n\n## Usage of the testing interface\n\nThe testing interface is located at \\`apps/testing_interface.html\\`. Open it in a web browser (Chrome recommended). It will prompt you to select a task JSON file.\n\nAfter loading a task, you will enter the test space, which looks like this:\n\n![test space](https://arc-benchmark.s3.amazonaws.com/figs/arc_test_space.png)\n\nOn the left, you will see the input/output pairs demonstrating the nature of the task. In the middle, you will see the current test input grid. On the right, you will see the controls you can use to construct the corresponding output grid.\n\nYou have access to the following tools:\n\n### Grid controls\n\n- Resize: input a grid size (e.g. \"10x20\" or \"4x4\") and click \"Resize\". This preserves existing grid content (in the top left corner).\n- Copy from input: copy the input grid to the output grid. This is useful for tasks where the output consists of some modification of the input.\n- Reset grid: fill the grid with 0s.\n\n### Symbol controls\n\n- Edit: select a color (symbol) from the color picking bar, then click on a cell to set its color.\n- Select: click and drag on either the output grid or the input grid to select cells.\n    - After selecting cells on the output grid, you can select a color from the color picking to set the color of the selected cells. This is useful to draw solid rectangles or lines.\n    - After selecting cells on either the input grid or the output grid, you can press C to copy their content. After copying, you can select a cell on the output grid and press \"V\" to paste the copied content. You should select the cell in the top left corner of the zone you want to paste into.\n- Floodfill: click on a cell from the output grid to color all connected cells to the selected color. \"Connected cells\" are contiguous cells with the same color.\n\n### Answer validation\n\nWhen your output grid is ready, click the green \"Submit!\" button to check your answer. We do not enforce the 3-trials rule.\n\nAfter you've obtained the correct answer for the current test input grid, you can switch to the next test input grid for the task using the \"Next test input\" button (if there is any available; most tasks only have one test input).\n\nWhen you're done with a task, use the \"load task\" button to open a new task.\n\n./apps/css/common.css\n\n.cell {\n    width: 100px;\n    height: 100px;\n    border-left: 1px solid #555;\n    border-top: 1px solid #555;\n    float: left;\n    background-color: #000;\n}\n\n.row {\n    clear: both;\n}\n\n.symbol_0 {\n    background-color: #000;\n}\n.symbol_1 {\n    background-color: #0074D9; /* blue */\n}\n.symbol_2 {\n    background-color: #FF4136; /* red */\n}\n.symbol_3 {\n    background-color: #2ECC40; /* green */\n}\n.symbol_4 {\n    background-color: #FFDC00; /* yellow */\n}\n.symbol_5 {\n    background-color: #AAAAAA; /* grey */\n}\n.symbol_6 {\n    background-color: #F012BE; /* fuschia */\n}\n.symbol_7 {\n    background-color: #FF851B; /* orange */\n}\n.symbol_8 {\n    background-color: #7FDBFF; /* teal */\n}\n.symbol_9 {\n    background-color: #870C25; /* brown */\n}\n\n\n/*Symbol picker*/\n\n.symbol_preview {\n    width: 20px;\n    height: 20px;\n    float: left;\n}\n\n.grid_size_field {\n    width: 50px;\n}\n\n.selected-symbol-preview {\n    border: 2px solid orange;\n}\n\n\n/*Selectable*/\n\n.ui-selected {\n    background-image: url(../img/black-twill.png), url(../img/brushed-alum.png);\n}\n.ui-selectable-helper {\n    border: 1px dotted #ddd;\n    position: absolute;\n    z-index: 1000;\n}\n\n/*Message display*/\n\n#error_display {\n    color: red;\n    width: 100%;\n    float: left;\n    font-size: 14px;\n    margin: 20px;\n}\n\n#info_display {\n    color: green;\n    width: 100%;\n    float: left;\n    font-size: 14px;\n    margin: 20px;\n}\n\n\n./apps/css/testing_interface.css\n\nbody {\n    font-family: 'Open Sans', sans-serif;\n    min-width: 1410px;\n}\n\n#workspace {\n    width: 1410px;\n    margin-left: auto;\n    margin-right: auto;\n}\n\n#demonstration_examples_view {\n    float: left;\n    width: 450px;\n    margin: 10px;\n    margin-right: 5px;\n    background-color: #d5d5d5;\n}\n\n#evaluation_view {\n    float: left;\n    width: 930px;\n    margin: 10px;\n    margin-left: 5px;\n    background-color: #d5d5d5;\n    min-height: 850px;\n}\n\n#evaluation-input-view {\n    float: left;\n    width: 400px;\n    margin: 10px;\n}\n\n#evaluation_output_editor {\n    float: left;\n    width: 500px;\n    margin-bottom: 20px;\n}\n\n#load_task_control_btns {\n    float: left;\n    margin-top: 10px;\n    margin-bottom: 0;\n    background: white;\n    width: 100%;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n#editor_grid_control_btns {\n    float: left;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    background: white;\n    width: 100%;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n#resize_control_btns {\n    width: 100%;\n    float:left;\n    margin-bottom: 10px;\n}\n\n#submit_solution_btn {\n    color: white;\n    border-radius: 4px;\n    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);\n    background: rgb(28, 184, 65);\n}\n\n#submit_solution_btn:active {\n  background: blue;\n}\n\nbutton:focus {outline:0;}\n\n#output_grid {\n\n}\n\n#toolbar {\n    float: left;\n    margin-left: 10px;\n    margin-top: 18px;\n    margin-bottom: 10px;\n    width: 100%;\n\n}\n\n#symbol_picker {\n    float: left;\n    margin-left: 20px;\n    width: 100%;\n}\n\n.symbol_preview {\n    width: 25px;\n    height: 25px;\n    float: left;\n}\n\nlabel {\n    margin-left: 10px;\n}\n\ninput, button {\n    margin-left: 10px;\n}\n\n#resize_btn {\n    margin-left: 0;\n}\n\n/*Task demonstration*/\n\n.pair_preview {\n    height: 200px;\n    padding: 5px;\n    border-bottom: solid 1px #a1a1a1;\n}\n.input_preview {\n    height: 200px;\n    width: 200px;\n    float: left;\n}\n.output_preview {\n    height: 200px;\n    width: 200px;\n    float: left;\n    margin-left: 35px;\n}\n\n.text {\n    text-align: center;\n    background: white;\n    padding-top: 5px;\n    padding-bottom: 5px;\n    margin-bottom: 10px;\n}\n\n#task_demo_header {\n    margin: 10px;\n}\n\n#modal_bg {\n    background-color: black;\n    width: 100%;\n    min-height: 10000px;\n    position: absolute;\n    top: 0;\n    left: 0;\n    overflow: hidden;\n}\n\n#modal {\n    margin: auto;\n    background-color: white;\n    text-align: center;\n    padding: 100px;\n    width: 500px;\n    margin-top: 100px;\n}\n\n#modal input {\n    margin-left: 70px;\n}\n\n./apps/js/common.js\n\n\nclass Grid {\n    constructor(height, width, values) {\n        this.height = height;\n        this.width = width;\n        this.grid = new Array(height);\n        for (var i = 0; i < height; i++){\n            this.grid[i] = new Array(width);\n            for (var j = 0; j < width; j++){\n                if (values != undefined && values[i] != undefined && values[i][j] != undefined){\n                    this.grid[i][j] = values[i][j];\n                } else {\n                    this.grid[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n\nfunction floodfillFromLocation(grid, i, j, symbol) {\n    i = parseInt(i);\n    j = parseInt(j);\n    symbol = parseInt(symbol);\n\n    target = grid[i][j];\n\n    if (target == symbol) {\n        return;\n    }\n\n    function flow(i, j, symbol, target) {\n        if (i >= 0 && i < grid.length && j >= 0 && j < grid[i].length) {\n            if (grid[i][j] == target) {\n                grid[i][j] = symbol;\n                flow(i - 1, j, symbol, target);\n                flow(i + 1, j, symbol, target);\n                flow(i, j - 1, symbol, target);\n                flow(i, j + 1, symbol, target);\n            }\n        }\n    }\n    flow(i, j, symbol, target);\n}\n\nfunction parseSizeTuple(size) {\n    size = size.split('x');\n    if (size.length != 2) {\n        alert('Grid size should have the format \"3x3\", \"5x7\", etc.');\n        return;\n    }\n    if ((size[0] < 1) || (size[1] < 1)) {\n        alert('Grid size should be at least 1. Cannot have a grid with no cells.');\n        return;\n    }\n    if ((size[0] > 30) || (size[1] > 30)) {\n        alert('Grid size should be at most 30 per side. Pick a smaller size.');\n        return;\n    }\n    return size;\n}\n\nfunction convertSerializedGridToGridObject(values) {\n    height = values.length;\n    width = values[0].length;\n    return new Grid(height, width, values)\n}\n\nfunction fitCellsToContainer(jqGrid, height, width, containerHeight, containerWidth) {\n    candidate_height = Math.floor((containerHeight - height) / height);\n    candidate_width = Math.floor((containerWidth - width) / width);\n    size = Math.min(candidate_height, candidate_width);\n    size = Math.min(MAX_CELL_SIZE, size);\n    jqGrid.find('.cell').css('height', size + 'px');\n    jqGrid.find('.cell').css('width', size + 'px');\n}\n\nfunction fillJqGridWithData(jqGrid, dataGrid) {\n    jqGrid.empty();\n    height = dataGrid.height;\n    width = dataGrid.width;\n    for (var i = 0; i < height; i++){\n        var row = \\$(document.createElement('div'));\n        row.addClass('row');\n        for (var j = 0; j < width; j++){\n            var cell = \\$(document.createElement('div'));\n            cell.addClass('cell');\n            cell.attr('x', i);\n            cell.attr('y', j);\n            setCellSymbol(cell, dataGrid.grid[i][j]);\n            row.append(cell);\n        }\n        jqGrid.append(row);\n    }\n}\n\nfunction copyJqGridToDataGrid(jqGrid, dataGrid) {\n    row_count = jqGrid.find('.row').length\n    if (dataGrid.height != row_count) {\n        return\n    }\n    col_count = jqGrid.find('.cell').length / row_count\n    if (dataGrid.width != col_count) {\n        return\n    }\n    jqGrid.find('.row').each(function(i, row) {\n        \\$(row).find('.cell').each(function(j, cell) {\n            dataGrid.grid[i][j] = parseInt(\\$(cell).attr('symbol'));\n        });\n    });\n}\n\nfunction setCellSymbol(cell, symbol) {\n    cell.attr('symbol', symbol);\n    classesToRemove = ''\n    for (i = 0; i < 10; i++) {\n        classesToRemove += 'symbol_' + i + ' ';\n    }\n    cell.removeClass(classesToRemove);\n    cell.addClass('symbol_' + symbol);\n}\n\nfunction errorMsg(msg) {\n    \\$('#error_display').stop(true, true);\n    \\$('#info_display').stop(true, true);\n\n    \\$('#error_display').hide();\n    \\$('#info_display').hide();\n    \\$('#error_display').html(msg);\n    \\$('#error_display').show();\n    \\$('#error_display').fadeOut(5000);\n}\n\nfunction infoMsg(msg) {\n    \\$('#error_display').stop(true, true);\n    \\$('#info_display').stop(true, true);\n\n    \\$('#info_display').hide();\n    \\$('#error_display').hide();\n    \\$('#info_display').html(msg);\n    \\$('#info_display').show();\n    \\$('#info_display').fadeOut(5000);\n}\n\n./apps/js/testing_interface.js\n\n\n// Internal state.\nvar CURRENT_INPUT_GRID = new Grid(3, 3);\nvar CURRENT_OUTPUT_GRID = new Grid(3, 3);\nvar TEST_PAIRS = new Array();\nvar CURRENT_TEST_PAIR_INDEX = 0;\nvar COPY_PASTE_DATA = new Array();\n\n// Cosmetic.\nvar EDITION_GRID_HEIGHT = 500;\nvar EDITION_GRID_WIDTH = 500;\nvar MAX_CELL_SIZE = 100;\n\n\nfunction resetTask() {\n    CURRENT_INPUT_GRID = new Grid(3, 3);\n    TEST_PAIRS = new Array();\n    CURRENT_TEST_PAIR_INDEX = 0;\n    \\$('#task_preview').html('');\n    resetOutputGrid();\n}\n\nfunction refreshEditionGrid(jqGrid, dataGrid) {\n    fillJqGridWithData(jqGrid, dataGrid);\n    setUpEditionGridListeners(jqGrid);\n    fitCellsToContainer(jqGrid, dataGrid.height, dataGrid.width, EDITION_GRID_HEIGHT, EDITION_GRID_HEIGHT);\n    initializeSelectable();\n}\n\nfunction syncFromEditionGridToDataGrid() {\n    copyJqGridToDataGrid(\\$('#output_grid .edition_grid'), CURRENT_OUTPUT_GRID);\n}\n\nfunction syncFromDataGridToEditionGrid() {\n    refreshEditionGrid(\\$('#output_grid .edition_grid'), CURRENT_OUTPUT_GRID);\n}\n\nfunction getSelectedSymbol() {\n    selected = \\$('#symbol_picker .selected-symbol-preview')[0];\n    return \\$(selected).attr('symbol');\n}\n\nfunction setUpEditionGridListeners(jqGrid) {\n    jqGrid.find('.cell').click(function(event) {\n        cell = \\$(event.target);\n        symbol = getSelectedSymbol();\n\n        mode = \\$('input[name=tool_switching]:checked').val();\n        if (mode == 'floodfill') {\n            // If floodfill: fill all connected cells.\n            syncFromEditionGridToDataGrid();\n            grid = CURRENT_OUTPUT_GRID.grid;\n            floodfillFromLocation(grid, cell.attr('x'), cell.attr('y'), symbol);\n            syncFromDataGridToEditionGrid();\n        }\n        else if (mode == 'edit') {\n            // Else: fill just this cell.\n            setCellSymbol(cell, symbol);\n        }\n    });\n}\n\nfunction resizeOutputGrid() {\n    size = \\$('#output_grid_size').val();\n    size = parseSizeTuple(size);\n    height = size[0];\n    width = size[1];\n\n    jqGrid = \\$('#output_grid .edition_grid');\n    syncFromEditionGridToDataGrid();\n    dataGrid = JSON.parse(JSON.stringify(CURRENT_OUTPUT_GRID.grid));\n    CURRENT_OUTPUT_GRID = new Grid(height, width, dataGrid);\n    refreshEditionGrid(jqGrid, CURRENT_OUTPUT_GRID);\n}\n\nfunction resetOutputGrid() {\n    syncFromEditionGridToDataGrid();\n    CURRENT_OUTPUT_GRID = new Grid(3, 3);\n    syncFromDataGridToEditionGrid();\n    resizeOutputGrid();\n}\n\nfunction copyFromInput() {\n    syncFromEditionGridToDataGrid();\n    CURRENT_OUTPUT_GRID = convertSerializedGridToGridObject(CURRENT_INPUT_GRID.grid);\n    syncFromDataGridToEditionGrid();\n    \\$('#output_grid_size').val(CURRENT_OUTPUT_GRID.height + 'x' + CURRENT_OUTPUT_GRID.width);\n}\n\nfunction fillPairPreview(pairId, inputGrid, outputGrid) {\n    var pairSlot = \\$('#pair_preview_' + pairId);\n    if (!pairSlot.length) {\n        // Create HTML for pair.\n        pairSlot = \\$('<div id=\"pair_preview_' + pairId + '\" class=\"pair_preview\" index=\"' + pairId + '\"></div>');\n        pairSlot.appendTo('#task_preview');\n    }\n    var jqInputGrid = pairSlot.find('.input_preview');\n    if (!jqInputGrid.length) {\n        jqInputGrid = \\$('<div class=\"input_preview\"></div>');\n        jqInputGrid.appendTo(pairSlot);\n    }\n    var jqOutputGrid = pairSlot.find('.output_preview');\n    if (!jqOutputGrid.length) {\n        jqOutputGrid = \\$('<div class=\"output_preview\"></div>');\n        jqOutputGrid.appendTo(pairSlot);\n    }\n\n    fillJqGridWithData(jqInputGrid, inputGrid);\n    fitCellsToContainer(jqInputGrid, inputGrid.height, inputGrid.width, 200, 200);\n    fillJqGridWithData(jqOutputGrid, outputGrid);\n    fitCellsToContainer(jqOutputGrid, outputGrid.height, outputGrid.width, 200, 200);\n}\n\nfunction loadJSONTask(train, test) {\n    resetTask();\n    \\$('#modal_bg').hide();\n    \\$('#error_display').hide();\n    \\$('#info_display').hide();\n\n    for (var i = 0; i < train.length; i++) {\n        pair = train[i];\n        values = pair['input'];\n        input_grid = convertSerializedGridToGridObject(values)\n        values = pair['output'];\n        output_grid = convertSerializedGridToGridObject(values)\n        fillPairPreview(i, input_grid, output_grid);\n    }\n    for (var i=0; i < test.length; i++) {\n        pair = test[i];\n        TEST_PAIRS.push(pair);\n    }\n    values = TEST_PAIRS[0]['input'];\n    CURRENT_INPUT_GRID = convertSerializedGridToGridObject(values)\n    fillTestInput(CURRENT_INPUT_GRID);\n    CURRENT_TEST_PAIR_INDEX = 0;\n    \\$('#current_test_input_id_display').html('1');\n    \\$('#total_test_input_count_display').html(test.length);\n}\n\nfunction display_task_name(task_name, task_index, number_of_tasks) {\n    big_space = '&nbsp;'.repeat(4); \n    document.getElementById('task_name').innerHTML = (\n        'Task name:' + big_space + task_name + big_space + (\n            task_index===null ? '' :\n            ( String(task_index) + ' out of ' + String(number_of_tasks) )\n        )\n    );\n}\n\nfunction loadTaskFromFile(e) {\n    var file = e.target.files[0];\n    if (!file) {\n        errorMsg('No file selected');\n        return;\n    }\n    var reader = new FileReader();\n    reader.onload = function(e) {\n        var contents = e.target.result;\n\n        try {\n            contents = JSON.parse(contents);\n            train = contents['train'];\n            test = contents['test'];\n        } catch (e) {\n            errorMsg('Bad file format');\n            return;\n        }\n        loadJSONTask(train, test);\n\n        \\$('#load_task_file_input')[0].value = \"\";\n        display_task_name(file.name, null, null);\n    };\n    reader.readAsText(file);\n}\n\nfunction randomTask() {\n    var subset = \"training\";\n    \\$.getJSON(\"https://api.github.com/repos/fchollet/ARC/contents/data/\" + subset, function(tasks) {\n        var task_index = Math.floor(Math.random() * tasks.length)\n        var task = tasks[task_index];\n        \\$.getJSON(task[\"download_url\"], function(json) {\n            try {\n                train = json['train'];\n                test = json['test'];\n            } catch (e) {\n                errorMsg('Bad file format');\n                return;\n            }\n            loadJSONTask(train, test);\n            //\\$('#load_task_file_input')[0].value = \"\";\n            infoMsg(\"Loaded task training/\" + task[\"name\"]);\n            display_task_name(task['name'], task_index, tasks.length);\n        })\n        .error(function(){\n          errorMsg('Error loading task');\n        });\n    })\n    .error(function(){\n      errorMsg('Error loading task list');\n    });\n}\n\nfunction nextTestInput() {\n    if (TEST_PAIRS.length <= CURRENT_TEST_PAIR_INDEX + 1) {\n        errorMsg('No next test input. Pick another file?')\n        return\n    }\n    CURRENT_TEST_PAIR_INDEX += 1;\n    values = TEST_PAIRS[CURRENT_TEST_PAIR_INDEX]['input'];\n    CURRENT_INPUT_GRID = convertSerializedGridToGridObject(values)\n    fillTestInput(CURRENT_INPUT_GRID);\n    \\$('#current_test_input_id_display').html(CURRENT_TEST_PAIR_INDEX + 1);\n    \\$('#total_test_input_count_display').html(test.length);\n}\n\nfunction submitSolution() {\n    syncFromEditionGridToDataGrid();\n    reference_output = TEST_PAIRS[CURRENT_TEST_PAIR_INDEX]['output'];\n    submitted_output = CURRENT_OUTPUT_GRID.grid;\n    if (reference_output.length != submitted_output.length) {\n        errorMsg('Wrong solution.');\n        return\n    }\n    for (var i = 0; i < reference_output.length; i++){\n        ref_row = reference_output[i];\n        for (var j = 0; j < ref_row.length; j++){\n            if (ref_row[j] != submitted_output[i][j]) {\n                errorMsg('Wrong solution.');\n                return\n            }\n        }\n\n    }\n    infoMsg('Correct solution!');\n}\n\nfunction fillTestInput(inputGrid) {\n    jqInputGrid = \\$('#evaluation_input');\n    fillJqGridWithData(jqInputGrid, inputGrid);\n    fitCellsToContainer(jqInputGrid, inputGrid.height, inputGrid.width, 400, 400);\n}\n\nfunction copyToOutput() {\n    syncFromEditionGridToDataGrid();\n    CURRENT_OUTPUT_GRID = convertSerializedGridToGridObject(CURRENT_INPUT_GRID.grid);\n    syncFromDataGridToEditionGrid();\n    \\$('#output_grid_size').val(CURRENT_OUTPUT_GRID.height + 'x' + CURRENT_OUTPUT_GRID.width);\n}\n\nfunction initializeSelectable() {\n    try {\n        \\$('.selectable_grid').selectable('destroy');\n    }\n    catch (e) {\n    }\n    toolMode = \\$('input[name=tool_switching]:checked').val();\n    if (toolMode == 'select') {\n        infoMsg('Select some cells and click on a color to fill in, or press C to copy');\n        \\$('.selectable_grid').selectable(\n            {\n                autoRefresh: false,\n                filter: '> .row > .cell',\n                start: function(event, ui) {\n                    \\$('.ui-selected').each(function(i, e) {\n                        \\$(e).removeClass('ui-selected');\n                    });\n                }\n            }\n        );\n    }\n}\n\n// Initial event binding.\n\n\\$(document).ready(function () {\n    \\$('#symbol_picker').find('.symbol_preview').click(function(event) {\n        symbol_preview = \\$(event.target);\n        \\$('#symbol_picker').find('.symbol_preview').each(function(i, preview) {\n            \\$(preview).removeClass('selected-symbol-preview');\n        })\n        symbol_preview.addClass('selected-symbol-preview');\n\n        toolMode = \\$('input[name=tool_switching]:checked').val();\n        if (toolMode == 'select') {\n            \\$('.edition_grid').find('.ui-selected').each(function(i, cell) {\n                symbol = getSelectedSymbol();\n                setCellSymbol(\\$(cell), symbol);\n            });\n        }\n    });\n\n    \\$('.edition_grid').each(function(i, jqGrid) {\n        setUpEditionGridListeners(\\$(jqGrid));\n    });\n\n    \\$('.load_task').on('change', function(event) {\n        loadTaskFromFile(event);\n    });\n\n    \\$('.load_task').on('click', function(event) {\n      event.target.value = \"\";\n    });\n\n    \\$('input[type=radio][name=tool_switching]').change(function() {\n        initializeSelectable();\n    });\n\n    \\$('input[type=text][name=size]').on('keydown', function(event) {\n        if (event.keyCode == 13) {\n            resizeOutputGrid();\n        }\n    });\n\n    \\$('body').keydown(function(event) {\n        // Copy and paste functionality.\n        if (event.which == 67) {\n            // Press C\n\n            selected = \\$('.ui-selected');\n            if (selected.length == 0) {\n                return;\n            }\n\n            COPY_PASTE_DATA = [];\n            for (var i = 0; i < selected.length; i ++) {\n                x = parseInt(\\$(selected[i]).attr('x'));\n                y = parseInt(\\$(selected[i]).attr('y'));\n                symbol = parseInt(\\$(selected[i]).attr('symbol'));\n                COPY_PASTE_DATA.push([x, y, symbol]);\n            }\n            infoMsg('Cells copied! Select a target cell and press V to paste at location.');\n\n        }\n        if (event.which == 86) {\n            // Press P\n            if (COPY_PASTE_DATA.length == 0) {\n                errorMsg('No data to paste.');\n                return;\n            }\n            selected = \\$('.edition_grid').find('.ui-selected');\n            if (selected.length == 0) {\n                errorMsg('Select a target cell on the output grid.');\n                return;\n            }\n\n            jqGrid = \\$(selected.parent().parent()[0]);\n\n            if (selected.length == 1) {\n                targetx = parseInt(selected.attr('x'));\n                targety = parseInt(selected.attr('y'));\n\n                xs = new Array();\n                ys = new Array();\n                symbols = new Array();\n\n                for (var i = 0; i < COPY_PASTE_DATA.length; i ++) {\n                    xs.push(COPY_PASTE_DATA[i][0]);\n                    ys.push(COPY_PASTE_DATA[i][1]);\n                    symbols.push(COPY_PASTE_DATA[i][2]);\n                }\n\n                minx = Math.min(...xs);\n                miny = Math.min(...ys);\n                for (var i = 0; i < xs.length; i ++) {\n                    x = xs[i];\n                    y = ys[i];\n                    symbol = symbols[i];\n                    newx = x - minx + targetx;\n                    newy = y - miny + targety;\n                    res = jqGrid.find('[x=\"' + newx + '\"][y=\"' + newy + '\"] ');\n                    if (res.length == 1) {\n                        cell = \\$(res[0]);\n                        setCellSymbol(cell, symbol);\n                    }\n                }\n            } else {\n                errorMsg('Can only paste at a specific location; only select *one* cell as paste destination.');\n            }\n        }\n    });\n});\n\n./apps/testing_interface.html\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>ARC testing interface</title>\n\n        <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"></script>\n        <script src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script>\n        <script src=\"js/common.js\"></script>\n        <script src=\"js/testing_interface.js\"></script>\n\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"css/common.css\">\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"css/testing_interface.css\">\n\n        <link href=\"https://fonts.googleapis.com/css?family=Open+Sans&display=swap\" rel=\"stylesheet\">\n\n    </head>\n    <body>\n        <div id=\"modal_bg\">\n            <div id=\"modal\">\n                <div>Welcome to the ARC testing interface. <br /> Choose a task file to start, or click on \"Random task\" to load one from the ARC project on github.</div>\n                <br />\n                <input type=\"file\" class=\"load_task\"/>\n                <button onclick=\"randomTask()\" id=\"random_task_btn\">Random task</button>\n            </div>\n        </div>\n        <div id=\"workspace\">\n\n            <div id=\"demonstration_examples_view\">\n                <div class=\"text\" id=\"task_demo_header\">Task demonstration</div>\n                <div id=\"task_preview\"></div>\n            </div>\n\n            <div id=\"evaluation_view\">\n\n                <div id=\"evaluation-input-view\">\n                    <div class=\"text\">Test input grid <span id=\"current_test_input_id_display\">0</span>/<span id=\"total_test_input_count_display\">0</span>\n                        <button onclick=\"nextTestInput()\">Next test input</button>\n                    </div>\n\n                    <div id=\"evaluation_input\" class=\"selectable_grid\"></div>\n                </div>\n\n                <div id=\"evaluation_output_editor\">\n\n                    <div id=\"load_task_control_btns\">\n                        <label for=\"load_task_file_input\">Load task JSON: </label>\n                        <input type=\"file\" id=\"load_task_file_input\" class=\"load_task\" style=\"display: none;\"/>\n                        <input type=\"button\" value=\"Browse...\" onclick=\"document.getElementById('load_task_file_input').click();\" />\n                        <button onclick=\"randomTask()\" id=\"random_task_btn\"> Random... </button>\n                        <p>\n                        <label id='task_name' for=\"random_task_btn\"> Task name: </label>\n                    </div>\n\n                    <div id=\"edition_view\">\n                        <div id=\"editor_grid_control_btns\">\n                            <div id=\"resize_control_btns\">\n                                <label for=\"output_grid_size\">Change grid size: </label>\n                                <input type=\"text\" id=\"output_grid_size\" class=\"grid_size_field\" name=\"size\" value=\"3x3\">\n                                <button onclick=\"resizeOutputGrid()\" id=\"resize_btn\">Resize</button>\n                            </div>\n\n                            <button onclick=\"copyFromInput()\">Copy from input</button>\n                            <button onclick=\"resetOutputGrid()\">Reset grid</button>\n                            <button onclick=\"submitSolution()\" id=\"submit_solution_btn\">Submit!</button>\n                        </div>\n\n                        <div id=\"output_grid\">\n                            <div class=\"edition_grid selectable_grid\">\n                                <div class=\"row\">\n                                    <div class=\"cell\" symbol=\"0\" x=\"0\" y=\"0\"></div>\n                                    <div class=\"cell\" symbol=\"0\" x=\"0\" y=\"1\"></div>\n                                    <div class=\"cell\" symbol=\"0\" x=\"0\" y=\"2\"></div>\n                                </div>\n                                <div class=\"row\">\n                                    <div class=\"cell\" symbol=\"0\" x=\"1\" y=\"0\"></div>\n                                    <div class=\"cell\" symbol=\"0\" x=\"1\" y=\"1\"></div>\n                                    <div class=\"cell\" symbol=\"0\" x=\"1\" y=\"2\"></div>\n                                </div>\n                                <div class=\"row\">\n                                    <div class=\"cell\" symbol=\"0\" x=\"2\" y=\"0\"></div>\n                                    <div class=\"cell\" symbol=\"0\" x=\"2\" y=\"1\"></div>\n                                    <div class=\"cell\" symbol=\"0\" x=\"2\" y=\"2\"></div>\n                                </div>\n                            </div>\n                        </div>\n\n\n                        <div id=\"toolbar\">\n                            <div>\n                                <input type=\"radio\" id=\"tool_edit\"\n                                 name=\"tool_switching\" value=\"edit\" checked>\n                                <label for=\"tool_edit\">Edit</label>\n\n                                <input type=\"radio\" id=\"tool_select\"\n                                 name=\"tool_switching\" value=\"select\">\n                                <label for=\"tool_select\">Select</label>\n\n                                <input type=\"radio\" id=\"tool_floodfill\"\n                                 name=\"tool_switching\" value=\"floodfill\">\n                                <label for=\"tool_floodfill\">Flood fill</label>\n                            </div>\n                        </div>\n\n                        <div id=\"symbol_picker\">\n                            <div class=\"symbol_preview symbol_0 selected-symbol-preview\" symbol=\"0\"></div>\n                            <div class=\"symbol_preview symbol_1\" symbol=\"1\"></div>\n                            <div class=\"symbol_preview symbol_2\" symbol=\"2\"></div>\n                            <div class=\"symbol_preview symbol_3\" symbol=\"3\"></div>\n                            <div class=\"symbol_preview symbol_4\" symbol=\"4\"></div>\n                            <div class=\"symbol_preview symbol_5\" symbol=\"5\"></div>\n                            <div class=\"symbol_preview symbol_6\" symbol=\"6\"></div>\n                            <div class=\"symbol_preview symbol_7\" symbol=\"7\"></div>\n                            <div class=\"symbol_preview symbol_8\" symbol=\"8\"></div>\n                            <div class=\"symbol_preview symbol_9\" symbol=\"9\"></div>\n                        </div>\n                    </div>\n\n                    <div id=\"error_display\"></div>\n                    <div id=\"info_display\"></div>\n                </div>\n            </div>\n        </div>\n    </body>\n</html>\n\n\\`\\`\\``;\n    try {\n        // loadTaskFromFile: Loads the task JSON file from the provided file path or URL\n        const loadTaskFromFile = async (userRequest)=>{\n            try {\n                let taskData = {};\n                // Check if userRequest is a valid URL\n                if ((0,_utils_notion_notionUtils__WEBPACK_IMPORTED_MODULE_2__.isValidUrl)(userRequest)) {\n                    // Fetch the task JSON file from the URL\n                    const response = await fetch(userRequest);\n                    if (!response.ok) {\n                    //throw new Error(`Failed to load task file from URL: ${userRequest}`);\n                    }\n                    taskData = await response.json();\n                } else {\n                    // Attempt to load the task JSON file from the local file system\n                    try {\n                        taskData = __webpack_require__(\"./pages/api/v1/skills sync recursive\")(userRequest);\n                    } catch (error) {\n                        // Log the error and provide a fallback solution\n                        debug += `Error loading task file from local path: ${error.message}\\n`;\n                        debug += `Attempting to load task file from GitHub...\\n`;\n                        // Use runCommand to search for the task file on GitHub\n                        const githubSearchPrompt = `search the fchollet/ARC repository on GitHub for a task file matching the name: ${userRequest}`;\n                        const githubSearchResult = await (0,_utils_skills_commandUtil__WEBPACK_IMPORTED_MODULE_1__.runCommand)(\"ultraBrowse\", githubSearchPrompt, phoneNumber, email);\n                        // Extract the task file URL from the search result\n                        const taskFileUrlRegex = /https:\\/\\/raw\\.githubusercontent\\.com\\/fchollet\\/ARC\\/master\\/data\\/\\w+\\/\\w+\\.json/;\n                        const taskFileUrlMatch = githubSearchResult.data.match(taskFileUrlRegex);\n                        if (taskFileUrlMatch) {\n                            const taskFileUrl = taskFileUrlMatch[0];\n                            debug += `Found task file on GitHub: ${taskFileUrl}\\n`;\n                            // Fetch the task JSON file from the GitHub URL\n                            const response1 = await fetch(taskFileUrl);\n                            if (!response1.ok) {\n                                throw new Error(`Failed to load task file from GitHub URL: ${taskFileUrl}`);\n                            }\n                            taskData = await response1.json();\n                        } else {\n                            throw new Error(`Could not find task file on GitHub: ${userRequest}`);\n                        }\n                    }\n                }\n                debug += `Loaded task data: ${JSON.stringify(taskData)}\\n`;\n                return taskData;\n            } catch (error1) {\n                debug += `Error in loadTaskFromFile: ${error1.message}\\n`;\n                // Return an empty object to allow the skill to continue executing\n                return {};\n            }\n        };\n        // parseTaskData: Parses the loaded task data to extract train and test pairs\n        const parseTaskData = async (taskData)=>{\n            try {\n                debug += `Parsing task data...\\n`;\n                console.log(\"Task data:\", taskData);\n                if (!taskData || typeof taskData !== \"object\") {\n                    throw new Error(\"Invalid task data format. Expected an object.\");\n                }\n                const trainPairs = taskData.train || [];\n                const testPairs = taskData.test || [];\n                if (!Array.isArray(trainPairs) || !Array.isArray(testPairs)) {\n                    throw new Error(\"Invalid train or test pairs format. Expected arrays.\");\n                }\n                debug += `Extracted ${trainPairs.length} train pairs and ${testPairs.length} test pairs.\\n`;\n                console.log(\"Train pairs:\", trainPairs);\n                console.log(\"Test pairs:\", testPairs);\n                return {\n                    trainPairs,\n                    testPairs\n                };\n            } catch (error) {\n                debug += `Error parsing task data: ${error.message}\\n`;\n                console.error(\"Error parsing task data:\", error);\n                return {\n                    trainPairs: [],\n                    testPairs: []\n                };\n            }\n        };\n        // analyzeTrainPairs: Uses AI to analyze the train pairs and identify transformation patterns.\n        const analyzeTrainPairs = async (trainPairs)=>{\n            try {\n                const analyzeTrainPairsPrompt = {\n                    systemPrompt: `You are an AI assistant that analyzes train pairs to identify transformation patterns in the ARC Solver skill. Given a set of train pairs, your task is to analyze each pair and identify the transformation rules that convert the input grid to the output grid. Provide a clear, concise description of each transformation rule you identify.`,\n                    prompt: `Here are the train pairs to analyze:\n<TrainPairs>\n${JSON.stringify(trainPairs, null, 2)}\n</TrainPairs>\nPlease analyze each train pair and identify the transformation rules that convert the input grid to the output grid. Provide a clear, concise description of each rule, one per line. If you are unsure or unable to identify a rule, simply write Unknown for that pair.\n    Reply with a markdown list of the rules, starting with the first rule now:`\n                };\n                const initialRulesResponse = await (0,_utils_gpt_gptUtils__WEBPACK_IMPORTED_MODULE_0__.gptRequest)(model, 0, analyzeTrainPairsPrompt.systemPrompt, analyzeTrainPairsPrompt.prompt, phoneNumber, email, 1024);\n                console.log(\"initialRulesResponse:\", initialRulesResponse);\n                debug += `Initial Rules Response:\\n${initialRulesResponse}\\n\\n`;\n                // Parse the initialRulesResponse into an array of strings\n                const initialRules = initialRulesResponse.split(\"\\n\").map((rule)=>rule.trim()).filter((rule)=>rule !== \"\");\n                console.log(\"initialRules:\", initialRules);\n                debug += `Initial Rules:\\n${JSON.stringify(initialRules, null, 2)}\\n\\n`;\n                return initialRules;\n            } catch (error) {\n                console.error(\"Error in analyzeTrainPairs:\", error.message);\n                debug += `Error in analyzeTrainPairs: ${error.message}\\n`;\n                return []; // Return an empty array as a fallback\n            }\n        };\n        // refineRules: Iteratively refines the transformation rules based on the train pairs\n        const refineRules = async (initialRules, trainPairs)=>{\n            let refinedRules = [\n                ...initialRules\n            ];\n            for(let i = 0; i < 20; i++){\n                refinedRules = [\n                    ...initialRules\n                ];\n                const refineRulesPrompt = {\n                    systemPrompt: `You are an AI assistant that refines transformation rules for solving ARC tasks. You will be given an array of initial rules and an array of train pairs. Your task is to iteratively refine the rules based on the train pairs to better capture the underlying patterns.\n\nFocus on capturing the general patterns rather than memorizing specific examples. You will only get a few chances, so try VERY different approaches each time if something is obviously not working, and please start by explicitly describe what is not working in previous rule sets before you write new rules. Describe your original thesis, why it was wrong based on the training pair you previously wrote vs the example set, and then formulate new rules. Describe your rules as properties applying to objects in the grid, and then describe the transformation rules that apply to each object over time, you will have better luck if you think spatially. Keep in mind that some of the tests may be rotated or resized but still apply the same rules, so think carefully about how you define objects to be resilient to these changes.\n\nRules refinement process:\n1. For each train pair, apply the current rules to the input grid and compare the result with the expected output grid.\n2. If the result does not match the expected output, identify the discrepancies and update the relevant rules to address them.\n3. Test the updated rules against all train pairs to ensure they produce the correct outputs.\n4. If any discrepancies remain, repeat steps 2-3 until all train pairs are correctly solved or a maximum number of iterations is reached.\n\nRemember to keep the rules as concise and generalizable as possible while still accurately capturing the transformation patterns. Avoid overfitting to specific train pairs.\n\nOutput format:\n<RefinedRules>\n1. Rule 1 description\n2. Rule 2 description\n...\n</RefinedRules>`,\n                    prompt: `Please refine the rules in terms of objects and transformations you're applying to those objects in the JSON pairs below.\n\n<Source Code Of The Testing Suite That Humans Use>\n${sourceCode}\n</Source Code Of The Testing Suite That Humans Use>\n\nRules refinement process:\n1. For each train pair, apply the current rules to the input grid and compare the result with the expected output grid.\n2. If the result does not match the expected output, identify the discrepancies and update the relevant rules to address them.\n3. Test the updated rules against all train pairs to ensure they produce the correct outputs.\n4. If any discrepancies remain, repeat steps 2-3 until all train pairs are correctly solved or a maximum number of iterations is reached.\n\nRemember to keep the rules as concise and generalizable as possible while still accurately capturing the transformation patterns. Avoid overfitting to specific train pairs.\n\n\nAnd here are the train pairs:\n\n<TrainPairs>\n${JSON.stringify(trainPairs, null, 2)}\n</TrainPairs>\n\n<Reasoning Tried So Far>\n${initialRules.join(\"\\n\")}\n</Reasoning Tried So Far>\n\nPlease refine the rules based on the train pairs and return the updated rules in the specified format. Focus on capturing the general patterns rather than memorizing specific examples. You will only get a few chances, so try VERY different approaches each time if something is obviously not working, and please start by explicitly describe what is not working in previous rule sets before you write new rules. Describe your original thesis, why it was wrong based on the training pair you previously wrote vs the example set, and then formulate new rules. Describe your rules as properties applying to objects in the grid, and then describe the transformation rules that apply to each object over time, you will have better luck if you think spatially. Keep in mind that some of the tests may be rotated or resized but still apply the same rules, so think carefully about how you define objects to be resilient to these changes.`\n                };\n                const refinementResult = await (0,_utils_gpt_gptUtils__WEBPACK_IMPORTED_MODULE_0__.gptRequest)(model, 0, refineRulesPrompt.systemPrompt, refineRulesPrompt.prompt, phoneNumber, email, 4000);\n                //debug += `Refinement iteration ${i + 1}:\\n${refinementResult}\\n\\n`;\n                //console.log(`Refinement iteration ${i + 1}:\\n${refinementResult}\\n\\n`);\n                // Extract the refined rules from the GPT response\n                const refinedRulesMatch = refinementResult.match(/<RefinedRules>([\\s\\S]*?)<\\/RefinedRules>/);\n                if (refinedRulesMatch) {\n                    refinedRules = refinedRulesMatch[1].trim().split(\"\\n\").map((rule)=>rule.trim());\n                    debug += `Extracted refined rules for iteration ${i + 1}: \\n${refinedRules.join(\"\\n\")}\\n\\n`;\n                    console.log(`Extracted refined rules for iteration ${i + 1}: \\n${refinedRules.join(\"\\n\")}\\n\\n`);\n                    // Test the refined rules against all train pairs\n                    let allTrainPairsSolved = true;\n                    for (const pair of trainPairs){\n                        const input = pair.input;\n                        const expectedOutput = pair.output;\n                        const actualOutput = applyRules(input, refinedRules);\n                        if (JSON.stringify(actualOutput) !== JSON.stringify(expectedOutput)) {\n                            allTrainPairsSolved = false;\n                            break;\n                        }\n                    }\n                    if (allTrainPairsSolved) {\n                        debug += \"All train pairs solved. Stopping refinement process.\\n\\n\";\n                        console.log(\"All train pairs solved. Stopping refinement process.\\n\\n\");\n                        break;\n                    }\n                } else {\n                    debug += \"Error: Could not extract refined rules from GPT response.\\n\\n\";\n                    console.error(\"Error: Could not extract refined rules from GPT response.\");\n                    break;\n                }\n            }\n            debug += `Final refined rules:\\n${refinedRules.join(\"\\n\")}\\n\\n`;\n            console.log(`Final refined rules:\\n${refinedRules.join(\"\\n\")}\\n\\n`);\n            return refinedRules;\n        };\n        // Helper function to apply rules to an input grid (implementation not shown)\n        const applyRules = (input, rules)=>{\n            // TODO: Implement logic to apply transformation rules to the input grid\n            return [];\n        };\n        // applyRulesToTestPairs: Applies the refined rules to the test pairs to generate solutions\n        const applyRulesToTestPairs = async (refinedRules, testPairs)=>{\n            try {\n                debug += `Applying refined rules to test pairs...\\n`;\n                console.log(`Refined Rules:\\n${refinedRules.join(\"\\n\")}`);\n                //console.log(`Test Pairs:\\n${JSON.stringify(testPairs, null, 2)}`);\n                const applyRulesPrompt = {\n                    systemPrompt: `You are an AI assistant that applies transformation rules to input grids to generate output grids. You will be given a set of refined transformation rules and a set of test pairs. Your task is to apply the rules to each test pair to generate the corresponding output grid solutions.\n\nProcess:\n1. For each test pair, apply the transformation rules to the input grid to generate the output grid solution.\n2. Provide a step-by-step explanation of how each rule was applied to transform the input grid into the output grid.\n3. If a rule cannot be applied or the transformation is ambiguous, provide your best attempt at a solution and explain any uncertainties or assumptions.\n\nGuidelines:\n- Be as specific and detailed as possible in your step-by-step explanations.\n- If a transformation rule is not directly applicable, use your best judgment to adapt it to the current test pair.\n- If multiple rules could apply, choose the one that seems most relevant based on the patterns observed in the training pairs.\n- For each test pair, provide the generated output grid and the associated explanation.\n\nOutput format:\n<TestPairSolutions>\nTest Pair 1:\nOutput Grid:\n[Generated output grid for Test Pair 1]\n\nStep-by-Step Explanation:\n1. [Explanation of how Rule 1 was applied]\n2. [Explanation of how Rule 2 was applied]\n...\n\nTest Pair 2:\nOutput Grid:\n[Generated output grid for Test Pair 2]\n\nStep-by-Step Explanation:\n1. [Explanation of how Rule 1 was applied]\n2. [Explanation of how Rule 2 was applied]\n...\n</TestPairSolutions>`,\n                    prompt: `Here are the refined transformation rules:\n<RefinedRules>\n${refinedRules.join(\"\\n\")}\n</RefinedRules>\n\nAnd here are the test pairs to solve:\n<TestPairs>\n${JSON.stringify(testPairs, null, 2)}\n</TestPairs>\n\nPlease apply the refined rules to each test pair to generate the output grid solutions and provide step-by-step explanations. Reply with the solutions and explanations in the specified output format.`\n                };\n                const solutionsResponse = await (0,_utils_gpt_gptUtils__WEBPACK_IMPORTED_MODULE_0__.gptRequest)(model, 0, applyRulesPrompt.systemPrompt, applyRulesPrompt.prompt, phoneNumber, email, 4000);\n                console.log(`Generated solutions response:\\n${solutionsResponse}`);\n                debug += `Generated solutions response:\\n${solutionsResponse}\\n\\n`;\n                // Parse the solutions response to extract the generated output grids and explanations\n                const solutionsMatch = solutionsResponse.match(/<TestPairSolutions>([\\s\\S]*)<\\/TestPairSolutions>/);\n                if (!solutionsMatch) {\n                    throw new Error(\"Could not parse test pair solutions from GPT response.\");\n                }\n                const solutionsText = solutionsMatch[1].trim();\n                const solutionRegex = /Test Pair (\\d+):\\s*Output Grid:\\s*(\\[[^\\]]+\\])\\s*Step-by-Step Explanation:\\s*((?:\\d+\\.\\s*(?:[^.\\n\\d][^\\n]*\\n?)*)+)/g;\n                const solutions = [];\n                let match;\n                while((match = solutionRegex.exec(solutionsText)) !== null){\n                    const [_, pairNumber, outputGrid, explanation] = match;\n                    solutions.push({\n                        pairNumber: parseInt(pairNumber),\n                        outputGrid: JSON.parse(outputGrid),\n                        explanation: explanation.trim()\n                    });\n                }\n                debug += `Parsed ${solutions.length} test pair solutions.\\n`;\n                console.log(\"Solutions:\", solutions);\n                return solutions;\n            } catch (error) {\n                debug += `Error in applyRulesToTestPairs: ${error.message}\\n`;\n                console.error(\"Error in applyRulesToTestPairs:\", error);\n                return [];\n            }\n        };\n        // formatSolutionDocument: Formats the step-by-step solution and explanations in a markdown document\n        const formatSolutionDocument = async (solutions, refinedRules)=>{\n            try {\n                const formatPrompt = {\n                    systemPrompt: `You are an AI assistant that formats the step-by-step ARC Solver solutions and explanations into a well-structured markdown document. Your task is to create a document that clearly presents the problem, the refined transformation rules, and the detailed solution for each test pair.`,\n                    prompt: `Here are the refined transformation rules:\n<RefinedRules>\n${refinedRules.join(\"\\n\")}\n</RefinedRules>\n\nAnd here are the step-by-step solutions for each test pair:\n<Solutions>\n${JSON.stringify(solutions, null, 2)}\n</Solutions>\n\nPlease format the information into a detailed markdown document. The document should include:\n\n1. A brief explanation of the ARC Solver task and the number of test pairs solved.\n\n2. A section presenting the refined transformation rules:\n## Refined Transformation Rules\n1. Rule 1\n2. Rule 2\n...\n\n3. For each test pair, include:\n### Test Pair N\n**Input Grid:**\n[Markdown table representing the input grid]\n\n**Output Grid:**\n[Markdown table representing the generated output grid]\n\n**Step-by-Step Explanation:**\n[Detailed step-by-step explanation of how the rules were applied]\n\nFeel free to use appropriate markdown formatting to ensure the document is clear, readable, and well-structured.\n\nPlease generate the complete solution document in markdown format now.`\n                };\n                const solutionDocumentResponse = await (0,_utils_gpt_gptUtils__WEBPACK_IMPORTED_MODULE_0__.gptRequest)(model, 0, formatPrompt.systemPrompt, formatPrompt.prompt, phoneNumber, email, 4000);\n                console.log(\"Solution Document Response:\", solutionDocumentResponse);\n                debug += `Generated solution document:\\n${solutionDocumentResponse}\\n\\n`;\n                return solutionDocumentResponse;\n            } catch (error) {\n                debug += `Error in formatSolutionDocument: ${error.message}\\n`;\n                console.error(\"Error in formatSolutionDocument:\", error);\n                return \"An error occurred while formatting the solution document.\";\n            }\n        };\n        // generateGridMarkdown: Converts the input/output grids to markdown tables\n        const generateGridMarkdown = async (grid)=>{\n            // Generate the markdown table header\n            let gridMarkdown = \"|\";\n            for(let col = 0; col < grid[0].length; col++){\n                gridMarkdown += \" |\";\n            }\n            gridMarkdown += \"\\n|\";\n            for(let col1 = 0; col1 < grid[0].length; col1++){\n                gridMarkdown += \"--|\";\n            }\n            gridMarkdown += \"\\n\";\n            // Generate the markdown table rows\n            for(let row = 0; row < grid.length; row++){\n                gridMarkdown += \"|\";\n                for(let col2 = 0; col2 < grid[row].length; col2++){\n                    const cellValue = grid[row][col2];\n                    gridMarkdown += ` ${cellValue} |`;\n                }\n                gridMarkdown += \"\\n\";\n            }\n            return gridMarkdown;\n        };\n        // sendSmsAlert: Sends an SMS alert to notify the user that the solution is ready\n        const sendSmsAlert = async (phoneNumber, solutionDocument)=>{\n            try {\n                const smsPrompt = {\n                    systemPrompt: \"You are an AI assistant that sends concise SMS alerts to notify users when their ARC Solver solution is ready.\",\n                    prompt: `The ARC Solver solution document is ready:\n\n<SolutionDocument>  \n${solutionDocument}\n</SolutionDocument>\n\nPlease draft a brief SMS alert message (max 160 characters) notifying the user that their solution is ready and where they can find the full details. The SMS should be friendly and to-the-point.`\n                };\n                const smsMessage = await (0,_utils_gpt_gptUtils__WEBPACK_IMPORTED_MODULE_0__.gptRequest)(model, 0, smsPrompt.systemPrompt, smsPrompt.prompt, phoneNumber, email, 200);\n                console.log(\"SMS Alert:\", smsMessage);\n                debug += `SMS alert message: ${smsMessage}\\n`;\n                // Send the actual SMS using an SMS service API (implementation not shown)\n                // sendSms(phoneNumber, smsMessage);\n                debug += `Send Fake SMS to ${phoneNumber} with message: ${smsMessage}\\n`;\n            } catch (error) {\n                debug += `Error in sendSmsAlert: ${error.message}\\n`;\n                console.error(\"Error in sendSmsAlert:\", error);\n            }\n        };\n        // returnSolutionResponse: Returns the formatted solution document and debug information as the API response\n        const returnSolutionResponse = async (solutionDocument, debug)=>{\n            try {\n                const responseBody = {\n                    message: solutionDocument,\n                    debug: debug\n                };\n                // Return the API response\n                return responseBody;\n            } catch (error) {\n                debug += `Error in returnSolutionResponse: ${error.message}\\n`;\n                console.error(\"Error in returnSolutionResponse:\", error);\n                // Return an error response\n                return {\n                    message: \"An error occurred while generating the solution response.\",\n                    debug: debug\n                };\n            }\n        };\n        // Main execution flow\n        const taskData = await loadTaskFromFile(userRequest);\n        const { trainPairs , testPairs  } = await parseTaskData(taskData);\n        const initialRules = await analyzeTrainPairs(trainPairs);\n        const refinedRules = await refineRules(initialRules, trainPairs);\n        const solutions = await applyRulesToTestPairs(refinedRules, testPairs);\n        const solutionDocument = await formatSolutionDocument(solutions, refinedRules);\n        // Generate markdown tables for input and output grids in each solution\n        for (const solution of solutions){\n            const inputGridMarkdown = await generateGridMarkdown(solution.inputGrid);\n            const outputGridMarkdown = await generateGridMarkdown(solution.outputGrid);\n            solution.inputGridMarkdown = inputGridMarkdown;\n            solution.outputGridMarkdown = outputGridMarkdown;\n        }\n        // Update the solution document with the grid markdowns\n        let solutionDocumentWithGrids = solutionDocument;\n        for (const solution1 of solutions){\n            solutionDocumentWithGrids = solutionDocumentWithGrids.replace(`[Input Grid for Test Pair ${solution1.pairNumber}]`, solution1.inputGridMarkdown).replace(`[Output Grid for Test Pair ${solution1.pairNumber}]`, solution1.outputGridMarkdown);\n        }\n        await sendSmsAlert(phoneNumber, solutionDocumentWithGrids);\n        const response = await returnSolutionResponse(solutionDocumentWithGrids, debug);\n        const beautifulOrganizedMarkdownReply = `${response.message}\n\n## Debug Information\n<details>\n<summary>Click to expand debug information</summary>\n\n${response.debug}\n\n</details>\n    `;\n        const smsReply = `Your ARC Solver solution is ready! Check your email or chat.heydata.org for the full solution details.`;\n        res.status(200).json({\n            message: beautifulOrganizedMarkdownReply,\n            debug: debug,\n            smsReply: smsReply\n        });\n    } catch (error) {\n        const errorSmsReply = `Sorry, I couldn't solve the ARC task you requested. See chat.heydata.org for details or try again with a different file.`;\n        console.error(\"Error in ARCSolver:\", error.message);\n        debug += `Error in ARCSolver: ${error.message}\\n`;\n        res.status(200).json({\n            message: `\n## An error occurred while running the ARC Solver skill ðŸ˜ž \nSorry! Something went wrong while processing the ARC task you requested. Here are some details about the error:\n\n<details>\n<summary><i>Click here for more technical details about the error...</i></summary>\n\n\\`\\`\\`\n${error.message}\n\\`\\`\\`\n\n\\`\\`\\`\n${debug}\n\\`\\`\\`\n\n</details>\n\n**Suggestions:**\n- Double check the format of the task JSON file you provided. It should match the expected format for ARC tasks.\n- Try a different task file, preferably one from the training set first to test.\n- If the issue persists, please reach out on chat.heydata.org for support. We'll do our best to resolve it!\n\nThanks for your patience and understanding. Let's solve some ARC tasks! ðŸ§©ðŸ’ª\n      `,\n            smsReply: errorSmsReply,\n            debug: debug\n        });\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (handler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvdjEvc2tpbGxzL25ld1NraWxsLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx3TEFBd0w7QUFHOUc7QUFDUjtBQUN1RDtBQUV6SCxNQUFNRyxPQUFPLEdBQUcsT0FBT0MsR0FBbUIsRUFBRUMsR0FBb0IsR0FBSztJQUNuRSxJQUFJLEVBQUVDLFdBQVcsR0FBRUMsV0FBVyxHQUFFQyxLQUFLLEdBQUVDLEtBQUssR0FBRUMsUUFBUSxHQUFFQyxlQUFlLEdBQUVDLGFBQWEsR0FBRUMsSUFBSSxHQUFFQyxVQUFVLEdBQUVDLEdBQUcsR0FBRSxHQUFHWCxHQUFHLENBQUNZLElBQUk7SUFFMUgsSUFBSUYsVUFBVSxLQUFLLFVBQVUsRUFBRTtRQUM3QixNQUFNRyxZQUFZLEdBQUc7WUFDbkJDLFFBQVEsRUFBRSxXQUFXO1lBQ3JCQyxXQUFXLEVBQUUsQ0FBQyxVQUFVLENBQUM7WUFDekJWLEtBQUssRUFBRSxDQUFDLHNCQUFzQixDQUFDO1lBQy9CVyxpQkFBaUIsRUFBRTtnQkFBQyxDQUFDLEtBQUssQ0FBQztnQkFBRSxDQUFDLGdCQUFnQixDQUFDO2FBQUM7WUFDaERDLEtBQUssRUFBRSxjQUFHO1lBQ1ZDLFdBQVcsRUFBRSxpQ0FBaUM7WUFDOUNDLElBQUksRUFBRSxpQ0FBaUM7WUFDdkNDLFdBQVcsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEtBMkJzSixDQUFDO1lBQ3JLQyxXQUFXLEVBQUUsQ0FBQyw2RkFBNkYsQ0FBQztZQUM1R0MsZ0JBQWdCLEVBQUUsR0FBRztZQUNyQkMsUUFBUSxFQUFFO2dCQUFDLEtBQUs7Z0JBQUUscUNBQXFDO2dCQUFFLFdBQVc7Z0JBQUUscUJBQXFCO2dCQUFFLGdCQUFnQjtnQkFBRSxzQkFBc0I7Z0JBQUUsaUJBQWlCO2dCQUFFLE9BQU87Z0JBQUUsV0FBVzthQUFDO1lBQy9LQyxZQUFZLEVBQUUsQ0FBQyxxT0FBcU8sQ0FBQztZQUNyUEMsZ0JBQWdCLEVBQUUsZ0JBQWdCO1lBQ2xDQyxpQkFBaUIsRUFBRSxPQUFPO1lBQzFCQyxjQUFjLEVBQUUsQ0FBQztZQUNqQkMsU0FBUyxFQUFFLEtBQUs7WUFDaEJDLFlBQVksRUFBRSxFQUFFO1lBQ2hCQyxVQUFVLEVBQUUsZ0JBQWdCO1lBQzVCQyxXQUFXLEVBQUUsQ0FBQzs7c0ZBRWtFLENBQUM7WUFDakZDLE9BQU8sRUFBRSxDQUFDOzs7b0ZBR29FLENBQUM7WUFDL0VDLFdBQVcsRUFBRSxDQUFDOzs7Ozs7OzttRkFRK0QsQ0FBQztZQUM5RUMsTUFBTSxFQUFFLGNBQWM7WUFDdEJDLFVBQVUsRUFBRSxxQ0FBcUM7WUFDakRDLFdBQVcsRUFBRSx3QkFBd0I7WUFDckNDLFVBQVUsRUFBRSxxQkFBcUI7WUFDakNDLFlBQVksRUFBRSxpQ0FBaUM7WUFDL0NDLFFBQVEsRUFBRSxxQkFBcUI7WUFDL0JDLFVBQVUsRUFBRSwwQkFBMEI7WUFDdENDLFNBQVMsRUFBRSxtQ0FBbUM7WUFDOUNDLFlBQVksRUFBRSxPQUFPO1lBQ3JCQyxXQUFXLEVBQUUsT0FBTztZQUNwQkMsTUFBTSxFQUFFLFdBQVc7WUFDbkJDLFNBQVMsRUFBRSw4Q0FBOEM7WUFDekRDLFNBQVMsRUFBRSw4Q0FBOEM7U0FDMUQ7UUFDRDdDLEdBQUcsQ0FBQzJDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQ0csSUFBSSxDQUFDO1lBQUVsQyxZQUFZO1NBQUUsQ0FBQyxDQUFDO1FBQ3ZDLE9BQU87SUFDVCxDQUFDO0lBRUQsSUFBSW1DLEtBQUssR0FBRyxFQUFFLEVBQUUsd0NBQXdDO0lBRTFELE1BQU1DLFVBQVUsR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BaS9CZCxDQUFDO0lBRUwsSUFBSTtRQUNGLGdGQUFnRjtRQUNoRixNQUFNQyxnQkFBZ0IsR0FBRyxPQUFPaEQsV0FBbUIsR0FBSztZQUN0RCxJQUFJ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SDVJLEdBQUcsQ0FBQzJDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQ0csSUFBSSxDQUFDO1lBQ25CVSxPQUFPLEVBQUVtRiwrQkFBK0I7WUFDeEM1RixLQUFLLEVBQUVBLEtBQUs7WUFDWjZGLFFBQVEsRUFBRUEsUUFBUTtTQUNuQixDQUFDLENBQUM7SUFFTCxFQUFFLE9BQU9yRixLQUFLLEVBQU87UUFDbkIsTUFBTXNGLGFBQWEsR0FBRyxDQUFDLHdIQUF3SCxDQUFDO1FBQ2hKekUsT0FBTyxDQUFDYixLQUFLLENBQUMscUJBQXFCLEVBQUVBLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7UUFDcERULEtBQUssSUFBSSxDQUFDLG9CQUFvQixFQUFFUSxLQUFLLENBQUNDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsRHhELEdBQUcsQ0FBQzJDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQ0csSUFBSSxDQUFDO1lBQ25CVSxPQUFPLEVBQUUsQ0FBQzs7Ozs7Ozs7QUFRaEIsRUFBRUQsS0FBSyxDQUFDQyxPQUFPLENBQUM7Ozs7QUFJaEIsRUFBRVQsS0FBSyxDQUFDOzs7Ozs7Ozs7OztNQVdGLENBQUM7WUFDRDZGLFFBQVEsRUFBRUMsYUFBYTtZQUN2QjlGLEtBQUssRUFBRUEsS0FBSztTQUNiLENBQUMsQ0FBQztJQUNMLENBQUM7QUFDSCxDQUFDO0FBRUQsaUVBQWVqRCxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9hcGkvdjEvc2tpbGxzL25ld1NraWxsLnRzPzVjZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgREFUQSBTa2lsbCwgbWFkZSBhdCBUdWVzZGF5LCBKdW5lIDExLCAyMDI0IGF0IDk6MjA6NDIuNzIzIFBNIE1EVCBieSBEQVRBLiBIZXJlIGlzIHdoZXJlIGl0IGlzIGxvY2F0ZWQgaW4gdGhlIHByb2plY3QgZmlsZTovLyBhcGkvdjEvc2tpbGxzL2FyY1NvbHZlci50c1xuXG5pbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XG5pbXBvcnQgeyBhY3RpdmF0ZURBVEEsIGdwdFJlcXVlc3QgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9ncHQvZ3B0VXRpbHMnO1xuaW1wb3J0IHsgcnVuQ29tbWFuZCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL3NraWxscy9jb21tYW5kVXRpbCc7XG5pbXBvcnQgeyBmZXRjaFZhbGlkSW1hZ2VVcmwsIGlzVmFsaWRVcmwsIGNvbXByZXNzSW1hZ2UsIHVwbG9hZEltYWdlVG9JbWd1ciB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL25vdGlvbi9ub3Rpb25VdGlscyc7XG5cbmNvbnN0IGhhbmRsZXIgPSBhc3luYyAocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpID0+IHtcbiAgbGV0IHsgdXNlclJlcXVlc3QsIHBob25lTnVtYmVyLCBlbWFpbCwgbW9kZWwsIGxvY2F0aW9uLCBjdXJyZW50VXNlclRpbWUsIGNsaXBib2FyZENvcHksIGFyZ3MsIHJldHVyblR5cGUsIGJvdCB9ID0gcmVxLmJvZHk7XG5cbiAgaWYgKHJldHVyblR5cGUgPT09ICdza2lsbERlZicpIHtcbiAgICBjb25zdCBkYXRhU2tpbGxEZWYgPSB7XG4gICAgICBmaWxlTmFtZTogJ2FyY1NvbHZlcicsXG4gICAgICBkaXNwbGF5TmFtZTogYEFSQyBTb2x2ZXJgLFxuICAgICAgbW9kZWw6IGBVc2VzIGN1cnJlbnQgc2VsZWN0aW9uYCxcbiAgICAgIHJlY29tbWVuZGVkTW9kZWxzOiBbYGdwdC00YCwgYGFudGhyb3BpYy1jbGF1ZGVgXSxcbiAgICAgIGVtb2ppOiAn8J+nqScsXG4gICAgICBoZWFkZXJJbWFnZTogJ2h0dHBzOi8vaS5pbWd1ci5jb20vaXU4bjZ5di5wbmcnLFxuICAgICAgaWNvbjogJ2h0dHBzOi8vaS5pbWd1ci5jb20vQjdiVFJOVi5wbmcnLFxuICAgICAgZGVzY3JpcHRpb246IGAjIyBBSS1Qb3dlcmVkIEFic3RyYWN0aW9uIGFuZCBSZWFzb25pbmcgQ2hhbGxlbmdlIChBUkMpIFNvbHZlciDwn6ep8J+SoVxuXG5UaGlzIHNraWxsIHRha2VzIGEgdXNlci1wcm92aWRlZCBBUkMgdGFzayBKU09OIGZpbGUsIGFuYWx5emVzIHRoZSB0cmFpbmluZyBwYWlycyB0byBpZGVudGlmeSB0cmFuc2Zvcm1hdGlvbiBwYXR0ZXJucywgaXRlcmF0aXZlbHkgcmVmaW5lcyB0aGUgcnVsZXMsIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIHRlc3QgcGFpcnMgdG8gZ2VuZXJhdGUgc3RlcC1ieS1zdGVwIHNvbHV0aW9ucy4gSXQgcmV0dXJucyBhIGZvcm1hdHRlZCBtYXJrZG93biBkb2N1bWVudCB3aXRoIHRoZSBzb2x1dGlvbiBzdGVwcyBhbmQgZXhwbGFuYXRpb25zLlxuXG4jIyMgVXNhZ2VcblRvIHVzZSB0aGlzIHNraWxsLCBwcm92aWRlIHRoZSBmaWxlIHBhdGggb3IgVVJMIHRvIGEgc2luZ2xlIEFSQyB0YXNrIEpTT04gZmlsZSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcblxuPHVzZXJSZXF1ZXN0PlxuUGxlYXNlIHNvbHZlIHRoZSBBUkMgdGFzayBpbiB0aGUgZmlsZSBbcGF0aC90by90YXNrLmpzb25dXG48L3VzZXJSZXF1ZXN0PlxuXG5UaGUgc2tpbGwgd2lsbCBsb2FkIHRoZSB0YXNrIGZpbGUsIGV4dHJhY3QgdGhlIHRyYWluaW5nIGFuZCB0ZXN0IHBhaXJzLCBhbmFseXplIHRoZSBwYXR0ZXJucywgcmVmaW5lIHRoZSBydWxlcywgYXBwbHkgdGhlbSB0byBnZW5lcmF0ZSBzb2x1dGlvbnMsIGFuZCByZXR1cm4gYSBkZXRhaWxlZCBtYXJrZG93biBzb2x1dGlvbiBkb2N1bWVudC5cblxuIyMjIENhcGFiaWxpdGllc1xuLSBIYW5kbGVzIGJvdGggbG9jYWwgZmlsZSBwYXRocyBhbmQgcmVtb3RlIFVSTHMgZm9yIHRhc2sgSlNPTiBmaWxlc1xuLSBBbmFseXplcyB0cmFpbmluZyBwYWlycyB1c2luZyBBSSB0byBpZGVudGlmeSB0cmFuc2Zvcm1hdGlvbiBwYXR0ZXJuc1xuLSBJdGVyYXRpdmVseSByZWZpbmVzIHRyYW5zZm9ybWF0aW9uIHJ1bGVzIGJhc2VkIG9uIHRyYWluaW5nIHBhaXJzXG4tIEFwcGxpZXMgcmVmaW5lZCBydWxlcyB0byB0ZXN0IHBhaXJzIHRvIGdlbmVyYXRlIHN0ZXAtYnktc3RlcCBzb2x1dGlvbnNcbi0gRm9ybWF0cyBzb2x1dGlvbiBzdGVwcyBhbmQgZXhwbGFuYXRpb25zIGluIGEgcmVhZGFibGUgbWFya2Rvd24gZG9jdW1lbnRcbi0gU2VuZHMgYW4gU01TIGFsZXJ0IHdoZW4gdGhlIHNvbHV0aW9uIGlzIHJlYWR5LCB3aXRoIGEgbGluayB0byB0aGUgZnVsbCBkb2N1bWVudFxuXG4jIyMgTGltaXRhdGlvbnNcbi0gTWF5IHN0cnVnZ2xlIHdpdGggaGlnaGx5IGNvbXBsZXggb3IgYWJzdHJhY3QgcGF0dGVybnMgYmV5b25kIHRoZSB0cmFpbmluZyBkYXRhXG4tIFNvbHV0aW9uIHF1YWxpdHkgZGVwZW5kcyBvbiB0aGUgYXZhaWxhYmxlIHRyYWluaW5nIHBhaXJzIGFuZCBtb2RlbCBwZXJmb3JtYW5jZVxuLSBMYXJnZSBvciBudW1lcm91cyB0ZXN0IHBhaXJzIG1heSBpbXBhY3QgcGVyZm9ybWFuY2UgYW5kIGdlbmVyYXRpb24gdGltZVxuXG4jIyMgUHJlcmVxdWlzaXRlc1xuVGhpcyBza2lsbCByZXF1aXJlcyB0aGUgdXNlciB0byBzdXBwbHkgYSB2YWxpZCBKU09OIGZpbGUgY29udGFpbmluZyBhbiBBUkMgdGFzayB3aXRoIHRyYWluaW5nIGFuZCB0ZXN0IHBhaXJzLiBUaGUgZmlsZSBzaG91bGQgYWRoZXJlIHRvIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmUgYW5kIGZvcm1hdC5gLFxuICAgICAgcmVsaWFiaWxpdHk6IGBSZWxpYWJsZSBvbiBtb3N0IEFSQyB0YXNrcywgYnV0IHBlcmZvcm1hbmNlIG1heSB2YXJ5IGZvciBoaWdobHkgY29tcGxleCBvciBhYnN0cmFjdCBwYXR0ZXJucy5gLFxuICAgICAgcmVsaWFiaWxpdHlSYXRpbzogMC44LFxuICAgICAga2V5d29yZHM6IFsnQVJDJywgJ0Fic3RyYWN0aW9uIGFuZCBSZWFzb25pbmcgQ2hhbGxlbmdlJywgJ0FJIHNvbHZlcicsICdwYXR0ZXJuIHJlY29nbml0aW9uJywgJ3J1bGUgaW5kdWN0aW9uJywgJ2dyaWQgdHJhbnNmb3JtYXRpb25zJywgJ3Byb2JsZW0gc29sdmluZycsICdsb2dpYycsICdyZWFzb25pbmcnXSxcbiAgICAgIGZhY3RDaGVja2luZzogYFRoaXMgc2tpbGwgZ2VuZXJhdGVzIHNvbHV0aW9uIHN0ZXBzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0YXNrIGZpbGUuIEZhY3QtY2hlY2tpbmcgaXMgbm90IGV4cGxpY2l0bHkgcGVyZm9ybWVkLCBhcyB0aGUgc2tpbGwgZm9jdXNlcyBvbiBkaXNjb3ZlcmluZyBwYXR0ZXJucyBhbmQgYXBwbHlpbmcgdHJhbnNmb3JtYXRpb25zIHJhdGhlciB0aGFuIHZlcmlmeWluZyBleHRlcm5hbCBpbmZvcm1hdGlvbi5gLFxuICAgICAgZXN0aW1hdGVkUnVuVGltZTogJzYwLTEyMCBzZWNvbmRzJyxcbiAgICAgIHNvdGFFc3RpbWF0ZWRDb3N0OiAnJDIuNTAnLFxuICAgICAgbWF4Q29uY3VycmVuY3k6IDUsXG4gICAgICBwcmVQcm9tcHQ6IGZhbHNlLFxuICAgICAgZGVwZW5kZW5jaWVzOiBbXSxcbiAgICAgIHNraWxsQ2xhc3M6ICdyZWN1cnNpdmVTa2lsbCcsXG4gICAgICBrbm93bklzc3VlczogYC0gTWF5IHN0cnVnZ2xlIHdpdGggaGlnaGx5IGFic3RyYWN0IG9yIGNvbXBsZXggcGF0dGVybnMgbm90IHdlbGwtcmVwcmVzZW50ZWQgaW4gdGhlIHRyYWluaW5nIGRhdGFcbi0gU29sdXRpb24gcXVhbGl0eSBhbmQgcGVyZm9ybWFuY2UgY2FuIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSBzcGVjaWZpYyB0YXNrIGFuZCBtb2RlbCB1c2VkXG4tIEV4dHJlbWVseSBsYXJnZSBvciBudW1lcm91cyB0ZXN0IHBhaXJzIG1heSBpbXBhY3QgZ2VuZXJhdGlvbiB0aW1lIGFuZCByZXNvdXJjZSB1c2FnZWAsXG4gICAgICByb2FkbWFwOiBgLSBFbmhhbmNlIHBhdHRlcm4gcmVjb2duaXRpb24gYW5kIHJ1bGUgaW5kdWN0aW9uIGNhcGFiaWxpdGllcyB0byBoYW5kbGUgbW9yZSBhYnN0cmFjdCB0YXNrc1xuLSBJbXByb3ZlIHNvbHV0aW9uIGV4cGxhbmF0aW9uIGNsYXJpdHkgYW5kIGFkZCB2aXN1YWxpemF0aW9ucyBmb3IgYmV0dGVyIHVuZGVyc3RhbmRpbmdcbi0gT3B0aW1pemUgcGVyZm9ybWFuY2UgZm9yIGxhcmdlciB0YXNrIHNldHMgYW5kIG1vcmUgZWZmaWNpZW50IHJlc291cmNlIHVzYWdlXG4tIEludGVncmF0ZSBhZGRpdGlvbmFsIEFJIG1vZGVscyBhbmQgdGVjaG5pcXVlcyBmb3IgaW1wcm92ZWQgYWNjdXJhY3kgYW5kIHJvYnVzdG5lc3NgLFxuICAgICAgd2Fsa3Rocm91Z2g6IGAxLiBSZWNlaXZlIHVzZXIgcmVxdWVzdCB3aXRoIHRoZSBmaWxlIHBhdGggb3IgVVJMIHRvIHRoZSBBUkMgdGFzayBKU09OIGZpbGVcbjIuIExvYWQgdGhlIHRhc2sgZmlsZSBhbmQgcGFyc2UgdGhlIHRyYWluaW5nIGFuZCB0ZXN0IHBhaXJzXG4zLiBBbmFseXplIHRoZSB0cmFpbmluZyBwYWlycyB1c2luZyBBSSB0byBpZGVudGlmeSB0cmFuc2Zvcm1hdGlvbiBwYXR0ZXJuc1xuNC4gR2VuZXJhdGUgaW5pdGlhbCBydWxlcyBiYXNlZCBvbiB0aGUgaWRlbnRpZmllZCBwYXR0ZXJuc1xuNS4gSXRlcmF0aXZlbHkgcmVmaW5lIHRoZSBydWxlcyBieSB0ZXN0aW5nIHRoZW0gYWdhaW5zdCB0aGUgdHJhaW5pbmcgcGFpcnMgYW5kIHVwZGF0aW5nIGFzIG5lZWRlZFxuNi4gQXBwbHkgdGhlIHJlZmluZWQgcnVsZXMgdG8gdGhlIHRlc3QgcGFpcnMgdG8gZ2VuZXJhdGUgc3RlcC1ieS1zdGVwIHNvbHV0aW9uc1xuNy4gRm9ybWF0IHRoZSBzb2x1dGlvbiBzdGVwcyBhbmQgZXhwbGFuYXRpb25zIGludG8gYSByZWFkYWJsZSBtYXJrZG93biBkb2N1bWVudFxuOC4gU2VuZCBhbiBTTVMgYWxlcnQgdG8gdGhlIHVzZXIgd2l0aCBhIGxpbmsgdG8gdGhlIGZ1bGwgc29sdXRpb24gZG9jdW1lbnRcbjkuIFJldHVybiB0aGUgZm9ybWF0dGVkIHNvbHV0aW9uIGRvY3VtZW50IGFuZCBkZWJ1ZyBpbmZvcm1hdGlvbiBhcyB0aGUgQVBJIHJlc3BvbnNlYCxcbiAgICAgIGF1dGhvcjogJ1N0ZXZlIE1vcmFjbycsXG4gICAgICBhdXRob3JEVUlEOiAnU3RldmVNb3JhY28tQ09TLTIwMjMtMTIwMS0wNDIwLTYwMDknLFxuICAgICAgcGF5cGFsRW1haWw6ICdzdGV2ZS5tb3JhY29AZ21haWwuY29tJyxcbiAgICAgIGRvbmF0ZUxpbms6ICdodHRwczovL2hleWRhdGEub3JnJyxcbiAgICAgIHNvY2lhbEhhbmRsZTogJ2h0dHBzOi8vdHdpdHRlci5jb20vU3RldmVNb3JhY28nLFxuICAgICAgcHJvbW9Vcmw6ICdodHRwczovL2hleWRhdGEub3JnJyxcbiAgICAgIHN1cHBvcnRVcmw6ICdodHRwczovL2hleWRhdGEub3JnL2NoYXQnLFxuICAgICAgc2tpbGxEVUlEOiAnQVJDU29sdmVyLUNPUy0yMDI0LTA2MTEtMjEyMC00MjcyJyxcbiAgICAgIHNraWxsVmVyc2lvbjogJzEuMC4wJyxcbiAgICAgIGRhdGFWZXJzaW9uOiAnNC4yLjAnLFxuICAgICAgc3RhdHVzOiAncHVibGlzaGVkJyxcbiAgICAgIGNyZWF0ZWRBdDogJ1R1ZXNkYXksIEp1bmUgMTEsIDIwMjQgYXQgOToyMDo0Mi43MjMgUE0gTURUJyxcbiAgICAgIHVwZGF0ZWRBdDogJ1R1ZXNkYXksIEp1bmUgMTEsIDIwMjQgYXQgOToyMDo0Mi43MjMgUE0gTURUJyxcbiAgICB9O1xuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgZGF0YVNraWxsRGVmIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBkZWJ1ZyA9ICcnOyAvLyBJbml0aWFsaXplIGRlYnVnIHZhcmlhYmxlIGZvciBsb2dnaW5nXG5cbmNvbnN0IHNvdXJjZUNvZGUgPSBgXFxgXFxgXFxgXG5BUkMtQUdJL1xuIOKUnOKUgOKUgCAuY2FjaGVcbiDilJzilIDilIAgLmdpdFxuIOKUnOKUgOKUgCBSRUFETUUubWRcbiDilJzilIDilIAgYXBwc1xuIHwgIOKUnOKUgOKUgCBjc3NcbiB8ICB8ICDilJzilIDilIAgY29tbW9uLmNzc1xuIHwgIHwgIOKUnOKUgOKUgCB0ZXN0aW5nX2ludGVyZmFjZS5jc3NcbiB8ICDilJzilIDilIAgaW1nXG4gfCAg4pSc4pSA4pSAIGpzXG4gfCAgfCAg4pSc4pSA4pSAIGNvbW1vbi5qc1xuIHwgIHwgIOKUnOKUgOKUgCB0ZXN0aW5nX2ludGVyZmFjZS5qc1xuIHwgIOKUnOKUgOKUgCB0ZXN0aW5nX2ludGVyZmFjZS5odG1sXG4g4pSc4pSA4pSAIGRhdGFcbiB8ICDilJzilIDilIAgZXZhbHVhdGlvblxuIHwgIOKUlOKUgOKUgCB0cmFpbmluZ1xuLi9SRUFETUUubWRcblxuIyBBYnN0cmFjdGlvbiBhbmQgUmVhc29uaW5nIENvcnB1cyBmb3IgQXJ0aWZpY2lhbCBHZW5lcmFsIEludGVsbGlnZW5jZSAoQVJDLUFHSSlcblxuVGhpcyByZXBvc2l0b3J5IGNvbnRhaW5zIHRoZSBBUkMtQUdJIHRhc2sgZGF0YSwgYXMgd2VsbCBhcyBhIGJyb3dzZXItYmFzZWQgaW50ZXJmYWNlIGZvciBodW1hbnMgdG8gdHJ5IHRoZWlyIGhhbmQgYXQgc29sdmluZyB0aGUgdGFza3MgbWFudWFsbHkuXG5cbipcIkFSQyBjYW4gYmUgc2VlbiBhcyBhIGdlbmVyYWwgYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgYmVuY2htYXJrLCBhcyBhIHByb2dyYW0gc3ludGhlc2lzIGJlbmNobWFyaywgb3IgYXMgYSBwc3ljaG9tZXRyaWMgaW50ZWxsaWdlbmNlIHRlc3QuIEl0IGlzIHRhcmdldGVkIGF0IGJvdGggaHVtYW5zIGFuZCBhcnRpZmljaWFsbHkgaW50ZWxsaWdlbnQgc3lzdGVtcyB0aGF0IGFpbSBhdCBlbXVsYXRpbmcgYSBodW1hbi1saWtlIGZvcm0gb2YgZ2VuZXJhbCBmbHVpZCBpbnRlbGxpZ2VuY2UuXCIqXG5cbkEgY29tcGxldGUgZGVzY3JpcHRpb24gb2YgdGhlIGRhdGFzZXQsIGl0cyBnb2FscywgYW5kIGl0cyB1bmRlcmx5aW5nIGxvZ2ljLCBjYW4gYmUgZm91bmQgaW46IFtPbiB0aGUgTWVhc3VyZSBvZiBJbnRlbGxpZ2VuY2VdKGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xOTExLjAxNTQ3KS5cblxuQXMgYSByZW1pbmRlciwgYSB0ZXN0LXRha2VyIGlzIHNhaWQgdG8gc29sdmUgYSB0YXNrIHdoZW4sIHVwb24gc2VlaW5nIHRoZSB0YXNrIGZvciB0aGUgZmlyc3QgdGltZSwgdGhleSBhcmUgYWJsZSB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG91dHB1dCBncmlkIGZvciAqYWxsKiB0ZXN0IGlucHV0cyBpbiB0aGUgdGFzayAodGhpcyBpbmNsdWRlcyBwaWNraW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQgZ3JpZCkuIEZvciBlYWNoIHRlc3QgaW5wdXQsIHRoZSB0ZXN0LXRha2VyIGlzIGFsbG93ZWQgMyB0cmlhbHMgKHRoaXMgaG9sZHMgZm9yIGFsbCB0ZXN0LXRha2VycywgZWl0aGVyIGh1bWFucyBvciBBSSkuXG5cblxuIyMgVGFzayBmaWxlIGZvcm1hdFxuXG5UaGUgXFxgZGF0YVxcYCBkaXJlY3RvcnkgY29udGFpbnMgdHdvIHN1YmRpcmVjdG9yaWVzOlxuXG4tIFxcYGRhdGEvdHJhaW5pbmdcXGA6IGNvbnRhaW5zIHRoZSB0YXNrIGZpbGVzIGZvciB0cmFpbmluZyAoNDAwIHRhc2tzKS4gVXNlIHRoZXNlIHRvIHByb3RvdHlwZSB5b3VyIGFsZ29yaXRobSBvciB0byB0cmFpbiB5b3VyIGFsZ29yaXRobSB0byBhY3F1aXJlIEFSQy1yZWxldmFudCBjb2duaXRpdmUgcHJpb3JzLlxuLSBcXGBkYXRhL2V2YWx1YXRpb25cXGA6IGNvbnRhaW5zIHRoZSB0YXNrIGZpbGVzIGZvciBldmFsdWF0aW9uICg0MDAgdGFza3MpLiBVc2UgdGhlc2UgdG8gZXZhbHVhdGUgeW91ciBmaW5hbCBhbGdvcml0aG0uIFRvIGVuc3VyZSBmYWlyIGV2YWx1YXRpb24gcmVzdWx0cywgZG8gbm90IGxlYWsgaW5mb3JtYXRpb24gZnJvbSB0aGUgZXZhbHVhdGlvbiBzZXQgaW50byB5b3VyIGFsZ29yaXRobSAoZS5nLiBieSBsb29raW5nIGF0IHRoZSBldmFsdWF0aW9uIHRhc2tzIHlvdXJzZWxmIGR1cmluZyBkZXZlbG9wbWVudCwgb3IgYnkgcmVwZWF0ZWRseSBtb2RpZnlpbmcgYW4gYWxnb3JpdGhtIHdoaWxlIHVzaW5nIGl0cyBldmFsdWF0aW9uIHNjb3JlIGFzIGZlZWRiYWNrKS5cblxuVGhlIHRhc2tzIGFyZSBzdG9yZWQgaW4gSlNPTiBmb3JtYXQuIEVhY2ggdGFzayBKU09OIGZpbGUgY29udGFpbnMgYSBkaWN0aW9uYXJ5IHdpdGggdHdvIGZpZWxkczpcblxuLSBcXGBcInRyYWluXCJcXGA6IGRlbW9uc3RyYXRpb24gaW5wdXQvb3V0cHV0IHBhaXJzLiBJdCBpcyBhIGxpc3Qgb2YgXCJwYWlyc1wiICh0eXBpY2FsbHkgMyBwYWlycykuXG4tIFxcYFwidGVzdFwiXFxgOiB0ZXN0IGlucHV0L291dHB1dCBwYWlycy4gSXQgaXMgYSBsaXN0IG9mIFwicGFpcnNcIiAodHlwaWNhbGx5IDEgcGFpcikuXG5cbkEgXCJwYWlyXCIgaXMgYSBkaWN0aW9uYXJ5IHdpdGggdHdvIGZpZWxkczpcblxuLSBcXGBcImlucHV0XCJcXGA6IHRoZSBpbnB1dCBcImdyaWRcIiBmb3IgdGhlIHBhaXIuXG4tIFxcYFwib3V0cHV0XCJcXGA6IHRoZSBvdXRwdXQgXCJncmlkXCIgZm9yIHRoZSBwYWlyLlxuXG5BIFwiZ3JpZFwiIGlzIGEgcmVjdGFuZ3VsYXIgbWF0cml4IChsaXN0IG9mIGxpc3RzKSBvZiBpbnRlZ2VycyBiZXR3ZWVuIDAgYW5kIDkgKGluY2x1c2l2ZSkuIFRoZSBzbWFsbGVzdCBwb3NzaWJsZSBncmlkIHNpemUgaXMgMXgxIGFuZCB0aGUgbGFyZ2VzdCBpcyAzMHgzMC5cblxuV2hlbiBsb29raW5nIGF0IGEgdGFzaywgYSB0ZXN0LXRha2VyIGhhcyBhY2Nlc3MgdG8gaW5wdXRzICYgb3V0cHV0cyBvZiB0aGUgZGVtb25zdHJhdGlvbiBwYWlycywgcGx1cyB0aGUgaW5wdXQocykgb2YgdGhlIHRlc3QgcGFpcihzKS4gVGhlIGdvYWwgaXMgdG8gY29uc3RydWN0IHRoZSBvdXRwdXQgZ3JpZChzKSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0ZXN0IGlucHV0IGdyaWQocyksIHVzaW5nIDMgdHJpYWxzIGZvciBlYWNoIHRlc3QgaW5wdXQuIFwiQ29uc3RydWN0aW5nIHRoZSBvdXRwdXQgZ3JpZFwiIGludm9sdmVzIHBpY2tpbmcgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIG91dHB1dCBncmlkLCB0aGVuIGZpbGxpbmcgZWFjaCBjZWxsIGluIHRoZSBncmlkIHdpdGggYSBzeW1ib2wgKGludGVnZXIgYmV0d2VlbiAwIGFuZCA5LCB3aGljaCBhcmUgdmlzdWFsaXplZCBhcyBjb2xvcnMpLiBPbmx5ICpleGFjdCogc29sdXRpb25zIChhbGwgY2VsbHMgbWF0Y2ggdGhlIGV4cGVjdGVkIGFuc3dlcikgY2FuIGJlIHNhaWQgdG8gYmUgY29ycmVjdC5cblxuXG4jIyBVc2FnZSBvZiB0aGUgdGVzdGluZyBpbnRlcmZhY2VcblxuVGhlIHRlc3RpbmcgaW50ZXJmYWNlIGlzIGxvY2F0ZWQgYXQgXFxgYXBwcy90ZXN0aW5nX2ludGVyZmFjZS5odG1sXFxgLiBPcGVuIGl0IGluIGEgd2ViIGJyb3dzZXIgKENocm9tZSByZWNvbW1lbmRlZCkuIEl0IHdpbGwgcHJvbXB0IHlvdSB0byBzZWxlY3QgYSB0YXNrIEpTT04gZmlsZS5cblxuQWZ0ZXIgbG9hZGluZyBhIHRhc2ssIHlvdSB3aWxsIGVudGVyIHRoZSB0ZXN0IHNwYWNlLCB3aGljaCBsb29rcyBsaWtlIHRoaXM6XG5cbiFbdGVzdCBzcGFjZV0oaHR0cHM6Ly9hcmMtYmVuY2htYXJrLnMzLmFtYXpvbmF3cy5jb20vZmlncy9hcmNfdGVzdF9zcGFjZS5wbmcpXG5cbk9uIHRoZSBsZWZ0LCB5b3Ugd2lsbCBzZWUgdGhlIGlucHV0L291dHB1dCBwYWlycyBkZW1vbnN0cmF0aW5nIHRoZSBuYXR1cmUgb2YgdGhlIHRhc2suIEluIHRoZSBtaWRkbGUsIHlvdSB3aWxsIHNlZSB0aGUgY3VycmVudCB0ZXN0IGlucHV0IGdyaWQuIE9uIHRoZSByaWdodCwgeW91IHdpbGwgc2VlIHRoZSBjb250cm9scyB5b3UgY2FuIHVzZSB0byBjb25zdHJ1Y3QgdGhlIGNvcnJlc3BvbmRpbmcgb3V0cHV0IGdyaWQuXG5cbllvdSBoYXZlIGFjY2VzcyB0byB0aGUgZm9sbG93aW5nIHRvb2xzOlxuXG4jIyMgR3JpZCBjb250cm9sc1xuXG4tIFJlc2l6ZTogaW5wdXQgYSBncmlkIHNpemUgKGUuZy4gXCIxMHgyMFwiIG9yIFwiNHg0XCIpIGFuZCBjbGljayBcIlJlc2l6ZVwiLiBUaGlzIHByZXNlcnZlcyBleGlzdGluZyBncmlkIGNvbnRlbnQgKGluIHRoZSB0b3AgbGVmdCBjb3JuZXIpLlxuLSBDb3B5IGZyb20gaW5wdXQ6IGNvcHkgdGhlIGlucHV0IGdyaWQgdG8gdGhlIG91dHB1dCBncmlkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgdGFza3Mgd2hlcmUgdGhlIG91dHB1dCBjb25zaXN0cyBvZiBzb21lIG1vZGlmaWNhdGlvbiBvZiB0aGUgaW5wdXQuXG4tIFJlc2V0IGdyaWQ6IGZpbGwgdGhlIGdyaWQgd2l0aCAwcy5cblxuIyMjIFN5bWJvbCBjb250cm9sc1xuXG4tIEVkaXQ6IHNlbGVjdCBhIGNvbG9yIChzeW1ib2wpIGZyb20gdGhlIGNvbG9yIHBpY2tpbmcgYmFyLCB0aGVuIGNsaWNrIG9uIGEgY2VsbCB0byBzZXQgaXRzIGNvbG9yLlxuLSBTZWxlY3Q6IGNsaWNrIGFuZCBkcmFnIG9uIGVpdGhlciB0aGUgb3V0cHV0IGdyaWQgb3IgdGhlIGlucHV0IGdyaWQgdG8gc2VsZWN0IGNlbGxzLlxuICAgIC0gQWZ0ZXIgc2VsZWN0aW5nIGNlbGxzIG9uIHRoZSBvdXRwdXQgZ3JpZCwgeW91IGNhbiBzZWxlY3QgYSBjb2xvciBmcm9tIHRoZSBjb2xvciBwaWNraW5nIHRvIHNldCB0aGUgY29sb3Igb2YgdGhlIHNlbGVjdGVkIGNlbGxzLiBUaGlzIGlzIHVzZWZ1bCB0byBkcmF3IHNvbGlkIHJlY3RhbmdsZXMgb3IgbGluZXMuXG4gICAgLSBBZnRlciBzZWxlY3RpbmcgY2VsbHMgb24gZWl0aGVyIHRoZSBpbnB1dCBncmlkIG9yIHRoZSBvdXRwdXQgZ3JpZCwgeW91IGNhbiBwcmVzcyBDIHRvIGNvcHkgdGhlaXIgY29udGVudC4gQWZ0ZXIgY29weWluZywgeW91IGNhbiBzZWxlY3QgYSBjZWxsIG9uIHRoZSBvdXRwdXQgZ3JpZCBhbmQgcHJlc3MgXCJWXCIgdG8gcGFzdGUgdGhlIGNvcGllZCBjb250ZW50LiBZb3Ugc2hvdWxkIHNlbGVjdCB0aGUgY2VsbCBpbiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB6b25lIHlvdSB3YW50IHRvIHBhc3RlIGludG8uXG4tIEZsb29kZmlsbDogY2xpY2sgb24gYSBjZWxsIGZyb20gdGhlIG91dHB1dCBncmlkIHRvIGNvbG9yIGFsbCBjb25uZWN0ZWQgY2VsbHMgdG8gdGhlIHNlbGVjdGVkIGNvbG9yLiBcIkNvbm5lY3RlZCBjZWxsc1wiIGFyZSBjb250aWd1b3VzIGNlbGxzIHdpdGggdGhlIHNhbWUgY29sb3IuXG5cbiMjIyBBbnN3ZXIgdmFsaWRhdGlvblxuXG5XaGVuIHlvdXIgb3V0cHV0IGdyaWQgaXMgcmVhZHksIGNsaWNrIHRoZSBncmVlbiBcIlN1Ym1pdCFcIiBidXR0b24gdG8gY2hlY2sgeW91ciBhbnN3ZXIuIFdlIGRvIG5vdCBlbmZvcmNlIHRoZSAzLXRyaWFscyBydWxlLlxuXG5BZnRlciB5b3UndmUgb2J0YWluZWQgdGhlIGNvcnJlY3QgYW5zd2VyIGZvciB0aGUgY3VycmVudCB0ZXN0IGlucHV0IGdyaWQsIHlvdSBjYW4gc3dpdGNoIHRvIHRoZSBuZXh0IHRlc3QgaW5wdXQgZ3JpZCBmb3IgdGhlIHRhc2sgdXNpbmcgdGhlIFwiTmV4dCB0ZXN0IGlucHV0XCIgYnV0dG9uIChpZiB0aGVyZSBpcyBhbnkgYXZhaWxhYmxlOyBtb3N0IHRhc2tzIG9ubHkgaGF2ZSBvbmUgdGVzdCBpbnB1dCkuXG5cbldoZW4geW91J3JlIGRvbmUgd2l0aCBhIHRhc2ssIHVzZSB0aGUgXCJsb2FkIHRhc2tcIiBidXR0b24gdG8gb3BlbiBhIG5ldyB0YXNrLlxuXG4uL2FwcHMvY3NzL2NvbW1vbi5jc3NcblxuLmNlbGwge1xuICAgIHdpZHRoOiAxMDBweDtcbiAgICBoZWlnaHQ6IDEwMHB4O1xuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgIzU1NTtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgIzU1NTtcbiAgICBmbG9hdDogbGVmdDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xufVxuXG4ucm93IHtcbiAgICBjbGVhcjogYm90aDtcbn1cblxuLnN5bWJvbF8wIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xufVxuLnN5bWJvbF8xIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3NEQ5OyAvKiBibHVlICovXG59XG4uc3ltYm9sXzIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRjQxMzY7IC8qIHJlZCAqL1xufVxuLnN5bWJvbF8zIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMkVDQzQwOyAvKiBncmVlbiAqL1xufVxuLnN5bWJvbF80IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZEQzAwOyAvKiB5ZWxsb3cgKi9cbn1cbi5zeW1ib2xfNSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0FBQUFBQTsgLyogZ3JleSAqL1xufVxuLnN5bWJvbF82IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjAxMkJFOyAvKiBmdXNjaGlhICovXG59XG4uc3ltYm9sXzcge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNGRjg1MUI7IC8qIG9yYW5nZSAqL1xufVxuLnN5bWJvbF84IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjN0ZEQkZGOyAvKiB0ZWFsICovXG59XG4uc3ltYm9sXzkge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM4NzBDMjU7IC8qIGJyb3duICovXG59XG5cblxuLypTeW1ib2wgcGlja2VyKi9cblxuLnN5bWJvbF9wcmV2aWV3IHtcbiAgICB3aWR0aDogMjBweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgZmxvYXQ6IGxlZnQ7XG59XG5cbi5ncmlkX3NpemVfZmllbGQge1xuICAgIHdpZHRoOiA1MHB4O1xufVxuXG4uc2VsZWN0ZWQtc3ltYm9sLXByZXZpZXcge1xuICAgIGJvcmRlcjogMnB4IHNvbGlkIG9yYW5nZTtcbn1cblxuXG4vKlNlbGVjdGFibGUqL1xuXG4udWktc2VsZWN0ZWQge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCguLi9pbWcvYmxhY2stdHdpbGwucG5nKSwgdXJsKC4uL2ltZy9icnVzaGVkLWFsdW0ucG5nKTtcbn1cbi51aS1zZWxlY3RhYmxlLWhlbHBlciB7XG4gICAgYm9yZGVyOiAxcHggZG90dGVkICNkZGQ7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDEwMDA7XG59XG5cbi8qTWVzc2FnZSBkaXNwbGF5Ki9cblxuI2Vycm9yX2Rpc3BsYXkge1xuICAgIGNvbG9yOiByZWQ7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIG1hcmdpbjogMjBweDtcbn1cblxuI2luZm9fZGlzcGxheSB7XG4gICAgY29sb3I6IGdyZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBtYXJnaW46IDIwcHg7XG59XG5cblxuLi9hcHBzL2Nzcy90ZXN0aW5nX2ludGVyZmFjZS5jc3NcblxuYm9keSB7XG4gICAgZm9udC1mYW1pbHk6ICdPcGVuIFNhbnMnLCBzYW5zLXNlcmlmO1xuICAgIG1pbi13aWR0aDogMTQxMHB4O1xufVxuXG4jd29ya3NwYWNlIHtcbiAgICB3aWR0aDogMTQxMHB4O1xuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICAgIG1hcmdpbi1yaWdodDogYXV0bztcbn1cblxuI2RlbW9uc3RyYXRpb25fZXhhbXBsZXNfdmlldyB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDQ1MHB4O1xuICAgIG1hcmdpbjogMTBweDtcbiAgICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDVkNWQ1O1xufVxuXG4jZXZhbHVhdGlvbl92aWV3IHtcbiAgICBmbG9hdDogbGVmdDtcbiAgICB3aWR0aDogOTMwcHg7XG4gICAgbWFyZ2luOiAxMHB4O1xuICAgIG1hcmdpbi1sZWZ0OiA1cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Q1ZDVkNTtcbiAgICBtaW4taGVpZ2h0OiA4NTBweDtcbn1cblxuI2V2YWx1YXRpb24taW5wdXQtdmlldyB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDQwMHB4O1xuICAgIG1hcmdpbjogMTBweDtcbn1cblxuI2V2YWx1YXRpb25fb3V0cHV0X2VkaXRvciB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDUwMHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG59XG5cbiNsb2FkX3Rhc2tfY29udHJvbF9idG5zIHtcbiAgICBmbG9hdDogbGVmdDtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZy10b3A6IDVweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogNXB4O1xufVxuXG4jZWRpdG9yX2dyaWRfY29udHJvbF9idG5zIHtcbiAgICBmbG9hdDogbGVmdDtcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZy10b3A6IDVweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogNXB4O1xufVxuXG4jcmVzaXplX2NvbnRyb2xfYnRucyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZmxvYXQ6bGVmdDtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xufVxuXG4jc3VibWl0X3NvbHV0aW9uX2J0biB7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICB0ZXh0LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjgsIDE4NCwgNjUpO1xufVxuXG4jc3VibWl0X3NvbHV0aW9uX2J0bjphY3RpdmUge1xuICBiYWNrZ3JvdW5kOiBibHVlO1xufVxuXG5idXR0b246Zm9jdXMge291dGxpbmU6MDt9XG5cbiNvdXRwdXRfZ3JpZCB7XG5cbn1cblxuI3Rvb2xiYXIge1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICAgIG1hcmdpbi10b3A6IDE4cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgICB3aWR0aDogMTAwJTtcblxufVxuXG4jc3ltYm9sX3BpY2tlciB7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbi5zeW1ib2xfcHJldmlldyB7XG4gICAgd2lkdGg6IDI1cHg7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIGZsb2F0OiBsZWZ0O1xufVxuXG5sYWJlbCB7XG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XG59XG5cbmlucHV0LCBidXR0b24ge1xuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xufVxuXG4jcmVzaXplX2J0biB7XG4gICAgbWFyZ2luLWxlZnQ6IDA7XG59XG5cbi8qVGFzayBkZW1vbnN0cmF0aW9uKi9cblxuLnBhaXJfcHJldmlldyB7XG4gICAgaGVpZ2h0OiAyMDBweDtcbiAgICBwYWRkaW5nOiA1cHg7XG4gICAgYm9yZGVyLWJvdHRvbTogc29saWQgMXB4ICNhMWExYTE7XG59XG4uaW5wdXRfcHJldmlldyB7XG4gICAgaGVpZ2h0OiAyMDBweDtcbiAgICB3aWR0aDogMjAwcHg7XG4gICAgZmxvYXQ6IGxlZnQ7XG59XG4ub3V0cHV0X3ByZXZpZXcge1xuICAgIGhlaWdodDogMjAwcHg7XG4gICAgd2lkdGg6IDIwMHB4O1xuICAgIGZsb2F0OiBsZWZ0O1xuICAgIG1hcmdpbi1sZWZ0OiAzNXB4O1xufVxuXG4udGV4dCB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgIHBhZGRpbmctdG9wOiA1cHg7XG4gICAgcGFkZGluZy1ib3R0b206IDVweDtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xufVxuXG4jdGFza19kZW1vX2hlYWRlciB7XG4gICAgbWFyZ2luOiAxMHB4O1xufVxuXG4jbW9kYWxfYmcge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1pbi1oZWlnaHQ6IDEwMDAwcHg7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbiNtb2RhbCB7XG4gICAgbWFyZ2luOiBhdXRvO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAxMDBweDtcbiAgICB3aWR0aDogNTAwcHg7XG4gICAgbWFyZ2luLXRvcDogMTAwcHg7XG59XG5cbiNtb2RhbCBpbnB1dCB7XG4gICAgbWFyZ2luLWxlZnQ6IDcwcHg7XG59XG5cbi4vYXBwcy9qcy9jb21tb24uanNcblxuXG5jbGFzcyBHcmlkIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQsIHdpZHRoLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspe1xuICAgICAgICAgICAgdGhpcy5ncmlkW2ldID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKyl7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcyAhPSB1bmRlZmluZWQgJiYgdmFsdWVzW2ldICE9IHVuZGVmaW5lZCAmJiB2YWx1ZXNbaV1bal0gIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkW2ldW2pdID0gdmFsdWVzW2ldW2pdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmbG9vZGZpbGxGcm9tTG9jYXRpb24oZ3JpZCwgaSwgaiwgc3ltYm9sKSB7XG4gICAgaSA9IHBhcnNlSW50KGkpO1xuICAgIGogPSBwYXJzZUludChqKTtcbiAgICBzeW1ib2wgPSBwYXJzZUludChzeW1ib2wpO1xuXG4gICAgdGFyZ2V0ID0gZ3JpZFtpXVtqXTtcblxuICAgIGlmICh0YXJnZXQgPT0gc3ltYm9sKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbG93KGksIGosIHN5bWJvbCwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpID49IDAgJiYgaSA8IGdyaWQubGVuZ3RoICYmIGogPj0gMCAmJiBqIDwgZ3JpZFtpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChncmlkW2ldW2pdID09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGdyaWRbaV1bal0gPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgZmxvdyhpIC0gMSwgaiwgc3ltYm9sLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGZsb3coaSArIDEsIGosIHN5bWJvbCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBmbG93KGksIGogLSAxLCBzeW1ib2wsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZmxvdyhpLCBqICsgMSwgc3ltYm9sLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZsb3coaSwgaiwgc3ltYm9sLCB0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpemVUdXBsZShzaXplKSB7XG4gICAgc2l6ZSA9IHNpemUuc3BsaXQoJ3gnKTtcbiAgICBpZiAoc2l6ZS5sZW5ndGggIT0gMikge1xuICAgICAgICBhbGVydCgnR3JpZCBzaXplIHNob3VsZCBoYXZlIHRoZSBmb3JtYXQgXCIzeDNcIiwgXCI1eDdcIiwgZXRjLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoc2l6ZVswXSA8IDEpIHx8IChzaXplWzFdIDwgMSkpIHtcbiAgICAgICAgYWxlcnQoJ0dyaWQgc2l6ZSBzaG91bGQgYmUgYXQgbGVhc3QgMS4gQ2Fubm90IGhhdmUgYSBncmlkIHdpdGggbm8gY2VsbHMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChzaXplWzBdID4gMzApIHx8IChzaXplWzFdID4gMzApKSB7XG4gICAgICAgIGFsZXJ0KCdHcmlkIHNpemUgc2hvdWxkIGJlIGF0IG1vc3QgMzAgcGVyIHNpZGUuIFBpY2sgYSBzbWFsbGVyIHNpemUuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTZXJpYWxpemVkR3JpZFRvR3JpZE9iamVjdCh2YWx1ZXMpIHtcbiAgICBoZWlnaHQgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHdpZHRoID0gdmFsdWVzWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IEdyaWQoaGVpZ2h0LCB3aWR0aCwgdmFsdWVzKVxufVxuXG5mdW5jdGlvbiBmaXRDZWxsc1RvQ29udGFpbmVyKGpxR3JpZCwgaGVpZ2h0LCB3aWR0aCwgY29udGFpbmVySGVpZ2h0LCBjb250YWluZXJXaWR0aCkge1xuICAgIGNhbmRpZGF0ZV9oZWlnaHQgPSBNYXRoLmZsb29yKChjb250YWluZXJIZWlnaHQgLSBoZWlnaHQpIC8gaGVpZ2h0KTtcbiAgICBjYW5kaWRhdGVfd2lkdGggPSBNYXRoLmZsb29yKChjb250YWluZXJXaWR0aCAtIHdpZHRoKSAvIHdpZHRoKTtcbiAgICBzaXplID0gTWF0aC5taW4oY2FuZGlkYXRlX2hlaWdodCwgY2FuZGlkYXRlX3dpZHRoKTtcbiAgICBzaXplID0gTWF0aC5taW4oTUFYX0NFTExfU0laRSwgc2l6ZSk7XG4gICAganFHcmlkLmZpbmQoJy5jZWxsJykuY3NzKCdoZWlnaHQnLCBzaXplICsgJ3B4Jyk7XG4gICAganFHcmlkLmZpbmQoJy5jZWxsJykuY3NzKCd3aWR0aCcsIHNpemUgKyAncHgnKTtcbn1cblxuZnVuY3Rpb24gZmlsbEpxR3JpZFdpdGhEYXRhKGpxR3JpZCwgZGF0YUdyaWQpIHtcbiAgICBqcUdyaWQuZW1wdHkoKTtcbiAgICBoZWlnaHQgPSBkYXRhR3JpZC5oZWlnaHQ7XG4gICAgd2lkdGggPSBkYXRhR3JpZC53aWR0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSsrKXtcbiAgICAgICAgdmFyIHJvdyA9IFxcJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIHJvdy5hZGRDbGFzcygncm93Jyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IFxcJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgICAgICBjZWxsLmFkZENsYXNzKCdjZWxsJyk7XG4gICAgICAgICAgICBjZWxsLmF0dHIoJ3gnLCBpKTtcbiAgICAgICAgICAgIGNlbGwuYXR0cigneScsIGopO1xuICAgICAgICAgICAgc2V0Q2VsbFN5bWJvbChjZWxsLCBkYXRhR3JpZC5ncmlkW2ldW2pdKTtcbiAgICAgICAgICAgIHJvdy5hcHBlbmQoY2VsbCk7XG4gICAgICAgIH1cbiAgICAgICAganFHcmlkLmFwcGVuZChyb3cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29weUpxR3JpZFRvRGF0YUdyaWQoanFHcmlkLCBkYXRhR3JpZCkge1xuICAgIHJvd19jb3VudCA9IGpxR3JpZC5maW5kKCcucm93JykubGVuZ3RoXG4gICAgaWYgKGRhdGFHcmlkLmhlaWdodCAhPSByb3dfY291bnQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbF9jb3VudCA9IGpxR3JpZC5maW5kKCcuY2VsbCcpLmxlbmd0aCAvIHJvd19jb3VudFxuICAgIGlmIChkYXRhR3JpZC53aWR0aCAhPSBjb2xfY291bnQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGpxR3JpZC5maW5kKCcucm93JykuZWFjaChmdW5jdGlvbihpLCByb3cpIHtcbiAgICAgICAgXFwkKHJvdykuZmluZCgnLmNlbGwnKS5lYWNoKGZ1bmN0aW9uKGosIGNlbGwpIHtcbiAgICAgICAgICAgIGRhdGFHcmlkLmdyaWRbaV1bal0gPSBwYXJzZUludChcXCQoY2VsbCkuYXR0cignc3ltYm9sJykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0Q2VsbFN5bWJvbChjZWxsLCBzeW1ib2wpIHtcbiAgICBjZWxsLmF0dHIoJ3N5bWJvbCcsIHN5bWJvbCk7XG4gICAgY2xhc3Nlc1RvUmVtb3ZlID0gJydcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjbGFzc2VzVG9SZW1vdmUgKz0gJ3N5bWJvbF8nICsgaSArICcgJztcbiAgICB9XG4gICAgY2VsbC5yZW1vdmVDbGFzcyhjbGFzc2VzVG9SZW1vdmUpO1xuICAgIGNlbGwuYWRkQ2xhc3MoJ3N5bWJvbF8nICsgc3ltYm9sKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JNc2cobXNnKSB7XG4gICAgXFwkKCcjZXJyb3JfZGlzcGxheScpLnN0b3AodHJ1ZSwgdHJ1ZSk7XG4gICAgXFwkKCcjaW5mb19kaXNwbGF5Jykuc3RvcCh0cnVlLCB0cnVlKTtcblxuICAgIFxcJCgnI2Vycm9yX2Rpc3BsYXknKS5oaWRlKCk7XG4gICAgXFwkKCcjaW5mb19kaXNwbGF5JykuaGlkZSgpO1xuICAgIFxcJCgnI2Vycm9yX2Rpc3BsYXknKS5odG1sKG1zZyk7XG4gICAgXFwkKCcjZXJyb3JfZGlzcGxheScpLnNob3coKTtcbiAgICBcXCQoJyNlcnJvcl9kaXNwbGF5JykuZmFkZU91dCg1MDAwKTtcbn1cblxuZnVuY3Rpb24gaW5mb01zZyhtc2cpIHtcbiAgICBcXCQoJyNlcnJvcl9kaXNwbGF5Jykuc3RvcCh0cnVlLCB0cnVlKTtcbiAgICBcXCQoJyNpbmZvX2Rpc3BsYXknKS5zdG9wKHRydWUsIHRydWUpO1xuXG4gICAgXFwkKCcjaW5mb19kaXNwbGF5JykuaGlkZSgpO1xuICAgIFxcJCgnI2Vycm9yX2Rpc3BsYXknKS5oaWRlKCk7XG4gICAgXFwkKCcjaW5mb19kaXNwbGF5JykuaHRtbChtc2cpO1xuICAgIFxcJCgnI2luZm9fZGlzcGxheScpLnNob3coKTtcbiAgICBcXCQoJyNpbmZvX2Rpc3BsYXknKS5mYWRlT3V0KDUwMDApO1xufVxuXG4uL2FwcHMvanMvdGVzdGluZ19pbnRlcmZhY2UuanNcblxuXG4vLyBJbnRlcm5hbCBzdGF0ZS5cbnZhciBDVVJSRU5UX0lOUFVUX0dSSUQgPSBuZXcgR3JpZCgzLCAzKTtcbnZhciBDVVJSRU5UX09VVFBVVF9HUklEID0gbmV3IEdyaWQoMywgMyk7XG52YXIgVEVTVF9QQUlSUyA9IG5ldyBBcnJheSgpO1xudmFyIENVUlJFTlRfVEVTVF9QQUlSX0lOREVYID0gMDtcbnZhciBDT1BZX1BBU1RFX0RBVEEgPSBuZXcgQXJyYXkoKTtcblxuLy8gQ29zbWV0aWMuXG52YXIgRURJVElPTl9HUklEX0hFSUdIVCA9IDUwMDtcbnZhciBFRElUSU9OX0dSSURfV0lEVEggPSA1MDA7XG52YXIgTUFYX0NFTExfU0laRSA9IDEwMDtcblxuXG5mdW5jdGlvbiByZXNldFRhc2soKSB7XG4gICAgQ1VSUkVOVF9JTlBVVF9HUklEID0gbmV3IEdyaWQoMywgMyk7XG4gICAgVEVTVF9QQUlSUyA9IG5ldyBBcnJheSgpO1xuICAgIENVUlJFTlRfVEVTVF9QQUlSX0lOREVYID0gMDtcbiAgICBcXCQoJyN0YXNrX3ByZXZpZXcnKS5odG1sKCcnKTtcbiAgICByZXNldE91dHB1dEdyaWQoKTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaEVkaXRpb25HcmlkKGpxR3JpZCwgZGF0YUdyaWQpIHtcbiAgICBmaWxsSnFHcmlkV2l0aERhdGEoanFHcmlkLCBkYXRhR3JpZCk7XG4gICAgc2V0VXBFZGl0aW9uR3JpZExpc3RlbmVycyhqcUdyaWQpO1xuICAgIGZpdENlbGxzVG9Db250YWluZXIoanFHcmlkLCBkYXRhR3JpZC5oZWlnaHQsIGRhdGFHcmlkLndpZHRoLCBFRElUSU9OX0dSSURfSEVJR0hULCBFRElUSU9OX0dSSURfSEVJR0hUKTtcbiAgICBpbml0aWFsaXplU2VsZWN0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBzeW5jRnJvbUVkaXRpb25HcmlkVG9EYXRhR3JpZCgpIHtcbiAgICBjb3B5SnFHcmlkVG9EYXRhR3JpZChcXCQoJyNvdXRwdXRfZ3JpZCAuZWRpdGlvbl9ncmlkJyksIENVUlJFTlRfT1VUUFVUX0dSSUQpO1xufVxuXG5mdW5jdGlvbiBzeW5jRnJvbURhdGFHcmlkVG9FZGl0aW9uR3JpZCgpIHtcbiAgICByZWZyZXNoRWRpdGlvbkdyaWQoXFwkKCcjb3V0cHV0X2dyaWQgLmVkaXRpb25fZ3JpZCcpLCBDVVJSRU5UX09VVFBVVF9HUklEKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRTeW1ib2woKSB7XG4gICAgc2VsZWN0ZWQgPSBcXCQoJyNzeW1ib2xfcGlja2VyIC5zZWxlY3RlZC1zeW1ib2wtcHJldmlldycpWzBdO1xuICAgIHJldHVybiBcXCQoc2VsZWN0ZWQpLmF0dHIoJ3N5bWJvbCcpO1xufVxuXG5mdW5jdGlvbiBzZXRVcEVkaXRpb25HcmlkTGlzdGVuZXJzKGpxR3JpZCkge1xuICAgIGpxR3JpZC5maW5kKCcuY2VsbCcpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNlbGwgPSBcXCQoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgc3ltYm9sID0gZ2V0U2VsZWN0ZWRTeW1ib2woKTtcblxuICAgICAgICBtb2RlID0gXFwkKCdpbnB1dFtuYW1lPXRvb2xfc3dpdGNoaW5nXTpjaGVja2VkJykudmFsKCk7XG4gICAgICAgIGlmIChtb2RlID09ICdmbG9vZGZpbGwnKSB7XG4gICAgICAgICAgICAvLyBJZiBmbG9vZGZpbGw6IGZpbGwgYWxsIGNvbm5lY3RlZCBjZWxscy5cbiAgICAgICAgICAgIHN5bmNGcm9tRWRpdGlvbkdyaWRUb0RhdGFHcmlkKCk7XG4gICAgICAgICAgICBncmlkID0gQ1VSUkVOVF9PVVRQVVRfR1JJRC5ncmlkO1xuICAgICAgICAgICAgZmxvb2RmaWxsRnJvbUxvY2F0aW9uKGdyaWQsIGNlbGwuYXR0cigneCcpLCBjZWxsLmF0dHIoJ3knKSwgc3ltYm9sKTtcbiAgICAgICAgICAgIHN5bmNGcm9tRGF0YUdyaWRUb0VkaXRpb25HcmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PSAnZWRpdCcpIHtcbiAgICAgICAgICAgIC8vIEVsc2U6IGZpbGwganVzdCB0aGlzIGNlbGwuXG4gICAgICAgICAgICBzZXRDZWxsU3ltYm9sKGNlbGwsIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzaXplT3V0cHV0R3JpZCgpIHtcbiAgICBzaXplID0gXFwkKCcjb3V0cHV0X2dyaWRfc2l6ZScpLnZhbCgpO1xuICAgIHNpemUgPSBwYXJzZVNpemVUdXBsZShzaXplKTtcbiAgICBoZWlnaHQgPSBzaXplWzBdO1xuICAgIHdpZHRoID0gc2l6ZVsxXTtcblxuICAgIGpxR3JpZCA9IFxcJCgnI291dHB1dF9ncmlkIC5lZGl0aW9uX2dyaWQnKTtcbiAgICBzeW5jRnJvbUVkaXRpb25HcmlkVG9EYXRhR3JpZCgpO1xuICAgIGRhdGFHcmlkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShDVVJSRU5UX09VVFBVVF9HUklELmdyaWQpKTtcbiAgICBDVVJSRU5UX09VVFBVVF9HUklEID0gbmV3IEdyaWQoaGVpZ2h0LCB3aWR0aCwgZGF0YUdyaWQpO1xuICAgIHJlZnJlc2hFZGl0aW9uR3JpZChqcUdyaWQsIENVUlJFTlRfT1VUUFVUX0dSSUQpO1xufVxuXG5mdW5jdGlvbiByZXNldE91dHB1dEdyaWQoKSB7XG4gICAgc3luY0Zyb21FZGl0aW9uR3JpZFRvRGF0YUdyaWQoKTtcbiAgICBDVVJSRU5UX09VVFBVVF9HUklEID0gbmV3IEdyaWQoMywgMyk7XG4gICAgc3luY0Zyb21EYXRhR3JpZFRvRWRpdGlvbkdyaWQoKTtcbiAgICByZXNpemVPdXRwdXRHcmlkKCk7XG59XG5cbmZ1bmN0aW9uIGNvcHlGcm9tSW5wdXQoKSB7XG4gICAgc3luY0Zyb21FZGl0aW9uR3JpZFRvRGF0YUdyaWQoKTtcbiAgICBDVVJSRU5UX09VVFBVVF9HUklEID0gY29udmVydFNlcmlhbGl6ZWRHcmlkVG9HcmlkT2JqZWN0KENVUlJFTlRfSU5QVVRfR1JJRC5ncmlkKTtcbiAgICBzeW5jRnJvbURhdGFHcmlkVG9FZGl0aW9uR3JpZCgpO1xuICAgIFxcJCgnI291dHB1dF9ncmlkX3NpemUnKS52YWwoQ1VSUkVOVF9PVVRQVVRfR1JJRC5oZWlnaHQgKyAneCcgKyBDVVJSRU5UX09VVFBVVF9HUklELndpZHRoKTtcbn1cblxuZnVuY3Rpb24gZmlsbFBhaXJQcmV2aWV3KHBhaXJJZCwgaW5wdXRHcmlkLCBvdXRwdXRHcmlkKSB7XG4gICAgdmFyIHBhaXJTbG90ID0gXFwkKCcjcGFpcl9wcmV2aWV3XycgKyBwYWlySWQpO1xuICAgIGlmICghcGFpclNsb3QubGVuZ3RoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBIVE1MIGZvciBwYWlyLlxuICAgICAgICBwYWlyU2xvdCA9IFxcJCgnPGRpdiBpZD1cInBhaXJfcHJldmlld18nICsgcGFpcklkICsgJ1wiIGNsYXNzPVwicGFpcl9wcmV2aWV3XCIgaW5kZXg9XCInICsgcGFpcklkICsgJ1wiPjwvZGl2PicpO1xuICAgICAgICBwYWlyU2xvdC5hcHBlbmRUbygnI3Rhc2tfcHJldmlldycpO1xuICAgIH1cbiAgICB2YXIganFJbnB1dEdyaWQgPSBwYWlyU2xvdC5maW5kKCcuaW5wdXRfcHJldmlldycpO1xuICAgIGlmICghanFJbnB1dEdyaWQubGVuZ3RoKSB7XG4gICAgICAgIGpxSW5wdXRHcmlkID0gXFwkKCc8ZGl2IGNsYXNzPVwiaW5wdXRfcHJldmlld1wiPjwvZGl2PicpO1xuICAgICAgICBqcUlucHV0R3JpZC5hcHBlbmRUbyhwYWlyU2xvdCk7XG4gICAgfVxuICAgIHZhciBqcU91dHB1dEdyaWQgPSBwYWlyU2xvdC5maW5kKCcub3V0cHV0X3ByZXZpZXcnKTtcbiAgICBpZiAoIWpxT3V0cHV0R3JpZC5sZW5ndGgpIHtcbiAgICAgICAganFPdXRwdXRHcmlkID0gXFwkKCc8ZGl2IGNsYXNzPVwib3V0cHV0X3ByZXZpZXdcIj48L2Rpdj4nKTtcbiAgICAgICAganFPdXRwdXRHcmlkLmFwcGVuZFRvKHBhaXJTbG90KTtcbiAgICB9XG5cbiAgICBmaWxsSnFHcmlkV2l0aERhdGEoanFJbnB1dEdyaWQsIGlucHV0R3JpZCk7XG4gICAgZml0Q2VsbHNUb0NvbnRhaW5lcihqcUlucHV0R3JpZCwgaW5wdXRHcmlkLmhlaWdodCwgaW5wdXRHcmlkLndpZHRoLCAyMDAsIDIwMCk7XG4gICAgZmlsbEpxR3JpZFdpdGhEYXRhKGpxT3V0cHV0R3JpZCwgb3V0cHV0R3JpZCk7XG4gICAgZml0Q2VsbHNUb0NvbnRhaW5lcihqcU91dHB1dEdyaWQsIG91dHB1dEdyaWQuaGVpZ2h0LCBvdXRwdXRHcmlkLndpZHRoLCAyMDAsIDIwMCk7XG59XG5cbmZ1bmN0aW9uIGxvYWRKU09OVGFzayh0cmFpbiwgdGVzdCkge1xuICAgIHJlc2V0VGFzaygpO1xuICAgIFxcJCgnI21vZGFsX2JnJykuaGlkZSgpO1xuICAgIFxcJCgnI2Vycm9yX2Rpc3BsYXknKS5oaWRlKCk7XG4gICAgXFwkKCcjaW5mb19kaXNwbGF5JykuaGlkZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWlyID0gdHJhaW5baV07XG4gICAgICAgIHZhbHVlcyA9IHBhaXJbJ2lucHV0J107XG4gICAgICAgIGlucHV0X2dyaWQgPSBjb252ZXJ0U2VyaWFsaXplZEdyaWRUb0dyaWRPYmplY3QodmFsdWVzKVxuICAgICAgICB2YWx1ZXMgPSBwYWlyWydvdXRwdXQnXTtcbiAgICAgICAgb3V0cHV0X2dyaWQgPSBjb252ZXJ0U2VyaWFsaXplZEdyaWRUb0dyaWRPYmplY3QodmFsdWVzKVxuICAgICAgICBmaWxsUGFpclByZXZpZXcoaSwgaW5wdXRfZ3JpZCwgb3V0cHV0X2dyaWQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpPTA7IGkgPCB0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhaXIgPSB0ZXN0W2ldO1xuICAgICAgICBURVNUX1BBSVJTLnB1c2gocGFpcik7XG4gICAgfVxuICAgIHZhbHVlcyA9IFRFU1RfUEFJUlNbMF1bJ2lucHV0J107XG4gICAgQ1VSUkVOVF9JTlBVVF9HUklEID0gY29udmVydFNlcmlhbGl6ZWRHcmlkVG9HcmlkT2JqZWN0KHZhbHVlcylcbiAgICBmaWxsVGVzdElucHV0KENVUlJFTlRfSU5QVVRfR1JJRCk7XG4gICAgQ1VSUkVOVF9URVNUX1BBSVJfSU5ERVggPSAwO1xuICAgIFxcJCgnI2N1cnJlbnRfdGVzdF9pbnB1dF9pZF9kaXNwbGF5JykuaHRtbCgnMScpO1xuICAgIFxcJCgnI3RvdGFsX3Rlc3RfaW5wdXRfY291bnRfZGlzcGxheScpLmh0bWwodGVzdC5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBkaXNwbGF5X3Rhc2tfbmFtZSh0YXNrX25hbWUsIHRhc2tfaW5kZXgsIG51bWJlcl9vZl90YXNrcykge1xuICAgIGJpZ19zcGFjZSA9ICcmbmJzcDsnLnJlcGVhdCg0KTsgXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rhc2tfbmFtZScpLmlubmVySFRNTCA9IChcbiAgICAgICAgJ1Rhc2sgbmFtZTonICsgYmlnX3NwYWNlICsgdGFza19uYW1lICsgYmlnX3NwYWNlICsgKFxuICAgICAgICAgICAgdGFza19pbmRleD09PW51bGwgPyAnJyA6XG4gICAgICAgICAgICAoIFN0cmluZyh0YXNrX2luZGV4KSArICcgb3V0IG9mICcgKyBTdHJpbmcobnVtYmVyX29mX3Rhc2tzKSApXG4gICAgICAgIClcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsb2FkVGFza0Zyb21GaWxlKGUpIHtcbiAgICB2YXIgZmlsZSA9IGUudGFyZ2V0LmZpbGVzWzBdO1xuICAgIGlmICghZmlsZSkge1xuICAgICAgICBlcnJvck1zZygnTm8gZmlsZSBzZWxlY3RlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBjb250ZW50cyA9IGUudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29udGVudHMgPSBKU09OLnBhcnNlKGNvbnRlbnRzKTtcbiAgICAgICAgICAgIHRyYWluID0gY29udGVudHNbJ3RyYWluJ107XG4gICAgICAgICAgICB0ZXN0ID0gY29udGVudHNbJ3Rlc3QnXTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JNc2coJ0JhZCBmaWxlIGZvcm1hdCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRKU09OVGFzayh0cmFpbiwgdGVzdCk7XG5cbiAgICAgICAgXFwkKCcjbG9hZF90YXNrX2ZpbGVfaW5wdXQnKVswXS52YWx1ZSA9IFwiXCI7XG4gICAgICAgIGRpc3BsYXlfdGFza19uYW1lKGZpbGUubmFtZSwgbnVsbCwgbnVsbCk7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tVGFzaygpIHtcbiAgICB2YXIgc3Vic2V0ID0gXCJ0cmFpbmluZ1wiO1xuICAgIFxcJC5nZXRKU09OKFwiaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9mY2hvbGxldC9BUkMvY29udGVudHMvZGF0YS9cIiArIHN1YnNldCwgZnVuY3Rpb24odGFza3MpIHtcbiAgICAgICAgdmFyIHRhc2tfaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0YXNrcy5sZW5ndGgpXG4gICAgICAgIHZhciB0YXNrID0gdGFza3NbdGFza19pbmRleF07XG4gICAgICAgIFxcJC5nZXRKU09OKHRhc2tbXCJkb3dubG9hZF91cmxcIl0sIGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHJhaW4gPSBqc29uWyd0cmFpbiddO1xuICAgICAgICAgICAgICAgIHRlc3QgPSBqc29uWyd0ZXN0J107XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNc2coJ0JhZCBmaWxlIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWRKU09OVGFzayh0cmFpbiwgdGVzdCk7XG4gICAgICAgICAgICAvL1xcJCgnI2xvYWRfdGFza19maWxlX2lucHV0JylbMF0udmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaW5mb01zZyhcIkxvYWRlZCB0YXNrIHRyYWluaW5nL1wiICsgdGFza1tcIm5hbWVcIl0pO1xuICAgICAgICAgICAgZGlzcGxheV90YXNrX25hbWUodGFza1snbmFtZSddLCB0YXNrX2luZGV4LCB0YXNrcy5sZW5ndGgpO1xuICAgICAgICB9KVxuICAgICAgICAuZXJyb3IoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlcnJvck1zZygnRXJyb3IgbG9hZGluZyB0YXNrJyk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgLmVycm9yKGZ1bmN0aW9uKCl7XG4gICAgICBlcnJvck1zZygnRXJyb3IgbG9hZGluZyB0YXNrIGxpc3QnKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gbmV4dFRlc3RJbnB1dCgpIHtcbiAgICBpZiAoVEVTVF9QQUlSUy5sZW5ndGggPD0gQ1VSUkVOVF9URVNUX1BBSVJfSU5ERVggKyAxKSB7XG4gICAgICAgIGVycm9yTXNnKCdObyBuZXh0IHRlc3QgaW5wdXQuIFBpY2sgYW5vdGhlciBmaWxlPycpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBDVVJSRU5UX1RFU1RfUEFJUl9JTkRFWCArPSAxO1xuICAgIHZhbHVlcyA9IFRFU1RfUEFJUlNbQ1VSUkVOVF9URVNUX1BBSVJfSU5ERVhdWydpbnB1dCddO1xuICAgIENVUlJFTlRfSU5QVVRfR1JJRCA9IGNvbnZlcnRTZXJpYWxpemVkR3JpZFRvR3JpZE9iamVjdCh2YWx1ZXMpXG4gICAgZmlsbFRlc3RJbnB1dChDVVJSRU5UX0lOUFVUX0dSSUQpO1xuICAgIFxcJCgnI2N1cnJlbnRfdGVzdF9pbnB1dF9pZF9kaXNwbGF5JykuaHRtbChDVVJSRU5UX1RFU1RfUEFJUl9JTkRFWCArIDEpO1xuICAgIFxcJCgnI3RvdGFsX3Rlc3RfaW5wdXRfY291bnRfZGlzcGxheScpLmh0bWwodGVzdC5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBzdWJtaXRTb2x1dGlvbigpIHtcbiAgICBzeW5jRnJvbUVkaXRpb25HcmlkVG9EYXRhR3JpZCgpO1xuICAgIHJlZmVyZW5jZV9vdXRwdXQgPSBURVNUX1BBSVJTW0NVUlJFTlRfVEVTVF9QQUlSX0lOREVYXVsnb3V0cHV0J107XG4gICAgc3VibWl0dGVkX291dHB1dCA9IENVUlJFTlRfT1VUUFVUX0dSSUQuZ3JpZDtcbiAgICBpZiAocmVmZXJlbmNlX291dHB1dC5sZW5ndGggIT0gc3VibWl0dGVkX291dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgZXJyb3JNc2coJ1dyb25nIHNvbHV0aW9uLicpO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZlcmVuY2Vfb3V0cHV0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgcmVmX3JvdyA9IHJlZmVyZW5jZV9vdXRwdXRbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVmX3Jvdy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICBpZiAocmVmX3Jvd1tqXSAhPSBzdWJtaXR0ZWRfb3V0cHV0W2ldW2pdKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNc2coJ1dyb25nIHNvbHV0aW9uLicpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgaW5mb01zZygnQ29ycmVjdCBzb2x1dGlvbiEnKTtcbn1cblxuZnVuY3Rpb24gZmlsbFRlc3RJbnB1dChpbnB1dEdyaWQpIHtcbiAgICBqcUlucHV0R3JpZCA9IFxcJCgnI2V2YWx1YXRpb25faW5wdXQnKTtcbiAgICBmaWxsSnFHcmlkV2l0aERhdGEoanFJbnB1dEdyaWQsIGlucHV0R3JpZCk7XG4gICAgZml0Q2VsbHNUb0NvbnRhaW5lcihqcUlucHV0R3JpZCwgaW5wdXRHcmlkLmhlaWdodCwgaW5wdXRHcmlkLndpZHRoLCA0MDAsIDQwMCk7XG59XG5cbmZ1bmN0aW9uIGNvcHlUb091dHB1dCgpIHtcbiAgICBzeW5jRnJvbUVkaXRpb25HcmlkVG9EYXRhR3JpZCgpO1xuICAgIENVUlJFTlRfT1VUUFVUX0dSSUQgPSBjb252ZXJ0U2VyaWFsaXplZEdyaWRUb0dyaWRPYmplY3QoQ1VSUkVOVF9JTlBVVF9HUklELmdyaWQpO1xuICAgIHN5bmNGcm9tRGF0YUdyaWRUb0VkaXRpb25HcmlkKCk7XG4gICAgXFwkKCcjb3V0cHV0X2dyaWRfc2l6ZScpLnZhbChDVVJSRU5UX09VVFBVVF9HUklELmhlaWdodCArICd4JyArIENVUlJFTlRfT1VUUFVUX0dSSUQud2lkdGgpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplU2VsZWN0YWJsZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBcXCQoJy5zZWxlY3RhYmxlX2dyaWQnKS5zZWxlY3RhYmxlKCdkZXN0cm95Jyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHRvb2xNb2RlID0gXFwkKCdpbnB1dFtuYW1lPXRvb2xfc3dpdGNoaW5nXTpjaGVja2VkJykudmFsKCk7XG4gICAgaWYgKHRvb2xNb2RlID09ICdzZWxlY3QnKSB7XG4gICAgICAgIGluZm9Nc2coJ1NlbGVjdCBzb21lIGNlbGxzIGFuZCBjbGljayBvbiBhIGNvbG9yIHRvIGZpbGwgaW4sIG9yIHByZXNzIEMgdG8gY29weScpO1xuICAgICAgICBcXCQoJy5zZWxlY3RhYmxlX2dyaWQnKS5zZWxlY3RhYmxlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1dG9SZWZyZXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6ICc+IC5yb3cgPiAuY2VsbCcsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICBcXCQoJy51aS1zZWxlY3RlZCcpLmVhY2goZnVuY3Rpb24oaSwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXFwkKGUpLnJlbW92ZUNsYXNzKCd1aS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vLyBJbml0aWFsIGV2ZW50IGJpbmRpbmcuXG5cblxcJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIFxcJCgnI3N5bWJvbF9waWNrZXInKS5maW5kKCcuc3ltYm9sX3ByZXZpZXcnKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzeW1ib2xfcHJldmlldyA9IFxcJChldmVudC50YXJnZXQpO1xuICAgICAgICBcXCQoJyNzeW1ib2xfcGlja2VyJykuZmluZCgnLnN5bWJvbF9wcmV2aWV3JykuZWFjaChmdW5jdGlvbihpLCBwcmV2aWV3KSB7XG4gICAgICAgICAgICBcXCQocHJldmlldykucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkLXN5bWJvbC1wcmV2aWV3Jyk7XG4gICAgICAgIH0pXG4gICAgICAgIHN5bWJvbF9wcmV2aWV3LmFkZENsYXNzKCdzZWxlY3RlZC1zeW1ib2wtcHJldmlldycpO1xuXG4gICAgICAgIHRvb2xNb2RlID0gXFwkKCdpbnB1dFtuYW1lPXRvb2xfc3dpdGNoaW5nXTpjaGVja2VkJykudmFsKCk7XG4gICAgICAgIGlmICh0b29sTW9kZSA9PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgXFwkKCcuZWRpdGlvbl9ncmlkJykuZmluZCgnLnVpLXNlbGVjdGVkJykuZWFjaChmdW5jdGlvbihpLCBjZWxsKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gZ2V0U2VsZWN0ZWRTeW1ib2woKTtcbiAgICAgICAgICAgICAgICBzZXRDZWxsU3ltYm9sKFxcJChjZWxsKSwgc3ltYm9sKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcXCQoJy5lZGl0aW9uX2dyaWQnKS5lYWNoKGZ1bmN0aW9uKGksIGpxR3JpZCkge1xuICAgICAgICBzZXRVcEVkaXRpb25HcmlkTGlzdGVuZXJzKFxcJChqcUdyaWQpKTtcbiAgICB9KTtcblxuICAgIFxcJCgnLmxvYWRfdGFzaycpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsb2FkVGFza0Zyb21GaWxlKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIFxcJCgnLmxvYWRfdGFzaycpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBldmVudC50YXJnZXQudmFsdWUgPSBcIlwiO1xuICAgIH0pO1xuXG4gICAgXFwkKCdpbnB1dFt0eXBlPXJhZGlvXVtuYW1lPXRvb2xfc3dpdGNoaW5nXScpLmNoYW5nZShmdW5jdGlvbigpIHtcbiAgICAgICAgaW5pdGlhbGl6ZVNlbGVjdGFibGUoKTtcbiAgICB9KTtcblxuICAgIFxcJCgnaW5wdXRbdHlwZT10ZXh0XVtuYW1lPXNpemVdJykub24oJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgcmVzaXplT3V0cHV0R3JpZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBcXCQoJ2JvZHknKS5rZXlkb3duKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIENvcHkgYW5kIHBhc3RlIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PSA2Nykge1xuICAgICAgICAgICAgLy8gUHJlc3MgQ1xuXG4gICAgICAgICAgICBzZWxlY3RlZCA9IFxcJCgnLnVpLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIENPUFlfUEFTVEVfREFUQSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZC5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gcGFyc2VJbnQoXFwkKHNlbGVjdGVkW2ldKS5hdHRyKCd4JykpO1xuICAgICAgICAgICAgICAgIHkgPSBwYXJzZUludChcXCQoc2VsZWN0ZWRbaV0pLmF0dHIoJ3knKSk7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gcGFyc2VJbnQoXFwkKHNlbGVjdGVkW2ldKS5hdHRyKCdzeW1ib2wnKSk7XG4gICAgICAgICAgICAgICAgQ09QWV9QQVNURV9EQVRBLnB1c2goW3gsIHksIHN5bWJvbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mb01zZygnQ2VsbHMgY29waWVkISBTZWxlY3QgYSB0YXJnZXQgY2VsbCBhbmQgcHJlc3MgViB0byBwYXN0ZSBhdCBsb2NhdGlvbi4nKTtcblxuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC53aGljaCA9PSA4Nikge1xuICAgICAgICAgICAgLy8gUHJlc3MgUFxuICAgICAgICAgICAgaWYgKENPUFlfUEFTVEVfREFUQS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnKCdObyBkYXRhIHRvIHBhc3RlLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGVkID0gXFwkKCcuZWRpdGlvbl9ncmlkJykuZmluZCgnLnVpLXNlbGVjdGVkJyk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvck1zZygnU2VsZWN0IGEgdGFyZ2V0IGNlbGwgb24gdGhlIG91dHB1dCBncmlkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAganFHcmlkID0gXFwkKHNlbGVjdGVkLnBhcmVudCgpLnBhcmVudCgpWzBdKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0eCA9IHBhcnNlSW50KHNlbGVjdGVkLmF0dHIoJ3gnKSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0eSA9IHBhcnNlSW50KHNlbGVjdGVkLmF0dHIoJ3knKSk7XG5cbiAgICAgICAgICAgICAgICB4cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgICAgIHlzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgc3ltYm9scyA9IG5ldyBBcnJheSgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDT1BZX1BBU1RFX0RBVEEubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhzLnB1c2goQ09QWV9QQVNURV9EQVRBW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgeXMucHVzaChDT1BZX1BBU1RFX0RBVEFbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xzLnB1c2goQ09QWV9QQVNURV9EQVRBW2ldWzJdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW54ID0gTWF0aC5taW4oLi4ueHMpO1xuICAgICAgICAgICAgICAgIG1pbnkgPSBNYXRoLm1pbiguLi55cyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHhzW2ldO1xuICAgICAgICAgICAgICAgICAgICB5ID0geXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld3ggPSB4IC0gbWlueCArIHRhcmdldHg7XG4gICAgICAgICAgICAgICAgICAgIG5ld3kgPSB5IC0gbWlueSArIHRhcmdldHk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGpxR3JpZC5maW5kKCdbeD1cIicgKyBuZXd4ICsgJ1wiXVt5PVwiJyArIG5ld3kgKyAnXCJdICcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gXFwkKHJlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDZWxsU3ltYm9sKGNlbGwsIHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnKCdDYW4gb25seSBwYXN0ZSBhdCBhIHNwZWNpZmljIGxvY2F0aW9uOyBvbmx5IHNlbGVjdCAqb25lKiBjZWxsIGFzIHBhc3RlIGRlc3RpbmF0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuLi9hcHBzL3Rlc3RpbmdfaW50ZXJmYWNlLmh0bWxcblxuPCFET0NUWVBFIGh0bWw+XG48aHRtbD5cbiAgICA8aGVhZD5cbiAgICAgICAgPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XG4gICAgICAgIDx0aXRsZT5BUkMgdGVzdGluZyBpbnRlcmZhY2U8L3RpdGxlPlxuXG4gICAgICAgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9hamF4Lmdvb2dsZWFwaXMuY29tL2FqYXgvbGlicy9qcXVlcnkvMS4xMi40L2pxdWVyeS5taW4uanNcIj48L3NjcmlwdD5cbiAgICAgICAgPHNjcmlwdCBzcmM9XCJodHRwczovL2NvZGUuanF1ZXJ5LmNvbS91aS8xLjEyLjEvanF1ZXJ5LXVpLmpzXCI+PC9zY3JpcHQ+XG4gICAgICAgIDxzY3JpcHQgc3JjPVwianMvY29tbW9uLmpzXCI+PC9zY3JpcHQ+XG4gICAgICAgIDxzY3JpcHQgc3JjPVwianMvdGVzdGluZ19pbnRlcmZhY2UuanNcIj48L3NjcmlwdD5cblxuICAgICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCIgaHJlZj1cImNzcy9jb21tb24uY3NzXCI+XG4gICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIiBocmVmPVwiY3NzL3Rlc3RpbmdfaW50ZXJmYWNlLmNzc1wiPlxuXG4gICAgICAgIDxsaW5rIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9T3BlbitTYW5zJmRpc3BsYXk9c3dhcFwiIHJlbD1cInN0eWxlc2hlZXRcIj5cblxuICAgIDwvaGVhZD5cbiAgICA8Ym9keT5cbiAgICAgICAgPGRpdiBpZD1cIm1vZGFsX2JnXCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwibW9kYWxcIj5cbiAgICAgICAgICAgICAgICA8ZGl2PldlbGNvbWUgdG8gdGhlIEFSQyB0ZXN0aW5nIGludGVyZmFjZS4gPGJyIC8+IENob29zZSBhIHRhc2sgZmlsZSB0byBzdGFydCwgb3IgY2xpY2sgb24gXCJSYW5kb20gdGFza1wiIHRvIGxvYWQgb25lIGZyb20gdGhlIEFSQyBwcm9qZWN0IG9uIGdpdGh1Yi48L2Rpdj5cbiAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBjbGFzcz1cImxvYWRfdGFza1wiLz5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uY2xpY2s9XCJyYW5kb21UYXNrKClcIiBpZD1cInJhbmRvbV90YXNrX2J0blwiPlJhbmRvbSB0YXNrPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJ3b3Jrc3BhY2VcIj5cblxuICAgICAgICAgICAgPGRpdiBpZD1cImRlbW9uc3RyYXRpb25fZXhhbXBsZXNfdmlld1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0XCIgaWQ9XCJ0YXNrX2RlbW9faGVhZGVyXCI+VGFzayBkZW1vbnN0cmF0aW9uPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cInRhc2tfcHJldmlld1wiPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJldmFsdWF0aW9uX3ZpZXdcIj5cblxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJldmFsdWF0aW9uLWlucHV0LXZpZXdcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHRcIj5UZXN0IGlucHV0IGdyaWQgPHNwYW4gaWQ9XCJjdXJyZW50X3Rlc3RfaW5wdXRfaWRfZGlzcGxheVwiPjA8L3NwYW4+LzxzcGFuIGlkPVwidG90YWxfdGVzdF9pbnB1dF9jb3VudF9kaXNwbGF5XCI+MDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25jbGljaz1cIm5leHRUZXN0SW5wdXQoKVwiPk5leHQgdGVzdCBpbnB1dDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiZXZhbHVhdGlvbl9pbnB1dFwiIGNsYXNzPVwic2VsZWN0YWJsZV9ncmlkXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiZXZhbHVhdGlvbl9vdXRwdXRfZWRpdG9yXCI+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImxvYWRfdGFza19jb250cm9sX2J0bnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJsb2FkX3Rhc2tfZmlsZV9pbnB1dFwiPkxvYWQgdGFzayBKU09OOiA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgaWQ9XCJsb2FkX3Rhc2tfZmlsZV9pbnB1dFwiIGNsYXNzPVwibG9hZF90YXNrXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJCcm93c2UuLi5cIiBvbmNsaWNrPVwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRfdGFza19maWxlX2lucHV0JykuY2xpY2soKTtcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPVwicmFuZG9tVGFzaygpXCIgaWQ9XCJyYW5kb21fdGFza19idG5cIj4gUmFuZG9tLi4uIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgaWQ9J3Rhc2tfbmFtZScgZm9yPVwicmFuZG9tX3Rhc2tfYnRuXCI+IFRhc2sgbmFtZTogPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImVkaXRpb25fdmlld1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImVkaXRvcl9ncmlkX2NvbnRyb2xfYnRuc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJyZXNpemVfY29udHJvbF9idG5zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJvdXRwdXRfZ3JpZF9zaXplXCI+Q2hhbmdlIGdyaWQgc2l6ZTogPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJvdXRwdXRfZ3JpZF9zaXplXCIgY2xhc3M9XCJncmlkX3NpemVfZmllbGRcIiBuYW1lPVwic2l6ZVwiIHZhbHVlPVwiM3gzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25jbGljaz1cInJlc2l6ZU91dHB1dEdyaWQoKVwiIGlkPVwicmVzaXplX2J0blwiPlJlc2l6ZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPVwiY29weUZyb21JbnB1dCgpXCI+Q29weSBmcm9tIGlucHV0PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPVwicmVzZXRPdXRwdXRHcmlkKClcIj5SZXNldCBncmlkPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPVwic3VibWl0U29sdXRpb24oKVwiIGlkPVwic3VibWl0X3NvbHV0aW9uX2J0blwiPlN1Ym1pdCE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPVwib3V0cHV0X2dyaWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZWRpdGlvbl9ncmlkIHNlbGVjdGFibGVfZ3JpZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMFwiIHk9XCIwXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMFwiIHk9XCIxXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMFwiIHk9XCIyXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMVwiIHk9XCIwXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMVwiIHk9XCIxXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMVwiIHk9XCIyXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMlwiIHk9XCIwXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMlwiIHk9XCIxXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2VsbFwiIHN5bWJvbD1cIjBcIiB4PVwiMlwiIHk9XCIyXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgaWQ9XCJ0b29sX2VkaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInRvb2xfc3dpdGNoaW5nXCIgdmFsdWU9XCJlZGl0XCIgY2hlY2tlZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInRvb2xfZWRpdFwiPkVkaXQ8L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBpZD1cInRvb2xfc2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJ0b29sX3N3aXRjaGluZ1wiIHZhbHVlPVwic2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJ0b29sX3NlbGVjdFwiPlNlbGVjdDwvbGFiZWw+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIGlkPVwidG9vbF9mbG9vZGZpbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInRvb2xfc3dpdGNoaW5nXCIgdmFsdWU9XCJmbG9vZGZpbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInRvb2xfZmxvb2RmaWxsXCI+Rmxvb2QgZmlsbDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cInN5bWJvbF9waWNrZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3ltYm9sX3ByZXZpZXcgc3ltYm9sXzAgc2VsZWN0ZWQtc3ltYm9sLXByZXZpZXdcIiBzeW1ib2w9XCIwXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN5bWJvbF9wcmV2aWV3IHN5bWJvbF8xXCIgc3ltYm9sPVwiMVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzeW1ib2xfcHJldmlldyBzeW1ib2xfMlwiIHN5bWJvbD1cIjJcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3ltYm9sX3ByZXZpZXcgc3ltYm9sXzNcIiBzeW1ib2w9XCIzXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN5bWJvbF9wcmV2aWV3IHN5bWJvbF80XCIgc3ltYm9sPVwiNFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzeW1ib2xfcHJldmlldyBzeW1ib2xfNVwiIHN5bWJvbD1cIjVcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3ltYm9sX3ByZXZpZXcgc3ltYm9sXzZcIiBzeW1ib2w9XCI2XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN5bWJvbF9wcmV2aWV3IHN5bWJvbF83XCIgc3ltYm9sPVwiN1wiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzeW1ib2xfcHJldmlldyBzeW1ib2xfOFwiIHN5bWJvbD1cIjhcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3ltYm9sX3ByZXZpZXcgc3ltYm9sXzlcIiBzeW1ib2w9XCI5XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImVycm9yX2Rpc3BsYXlcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImluZm9fZGlzcGxheVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvYm9keT5cbjwvaHRtbD5cblxuXFxgXFxgXFxgYDtcblxuICB0cnkge1xuICAgIC8vIGxvYWRUYXNrRnJvbUZpbGU6IExvYWRzIHRoZSB0YXNrIEpTT04gZmlsZSBmcm9tIHRoZSBwcm92aWRlZCBmaWxlIHBhdGggb3IgVVJMXG4gICAgY29uc3QgbG9hZFRhc2tGcm9tRmlsZSA9IGFzeW5jICh1c2VyUmVxdWVzdDogc3RyaW5nKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdGFza0RhdGEgPSB7fTtcblxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyUmVxdWVzdCBpcyBhIHZhbGlkIFVSTFxuICAgICAgICBpZiAoaXNWYWxpZFVybCh1c2VyUmVxdWVzdCkpIHtcbiAgICAgICAgICAvLyBGZXRjaCB0aGUgdGFzayBKU09OIGZpbGUgZnJvbSB0aGUgVVJMXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1c2VyUmVxdWVzdCk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHRhc2sgZmlsZSBmcm9tIFVSTDogJHt1c2VyUmVxdWVzdH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFza0RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSB0YXNrIEpTT04gZmlsZSBmcm9tIHRoZSBsb2NhbCBmaWxlIHN5c3RlbVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrRGF0YSA9IHJlcXVpcmUodXNlclJlcXVlc3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgIC8vIExvZyB0aGUgZXJyb3IgYW5kIHByb3ZpZGUgYSBmYWxsYmFjayBzb2x1dGlvblxuICAgICAgICAgICAgZGVidWcgKz0gYEVycm9yIGxvYWRpbmcgdGFzayBmaWxlIGZyb20gbG9jYWwgcGF0aDogJHtlcnJvci5tZXNzYWdlfVxcbmA7XG4gICAgICAgICAgICBkZWJ1ZyArPSBgQXR0ZW1wdGluZyB0byBsb2FkIHRhc2sgZmlsZSBmcm9tIEdpdEh1Yi4uLlxcbmA7XG5cbiAgICAgICAgICAgIC8vIFVzZSBydW5Db21tYW5kIHRvIHNlYXJjaCBmb3IgdGhlIHRhc2sgZmlsZSBvbiBHaXRIdWJcbiAgICAgICAgICAgIGNvbnN0IGdpdGh1YlNlYXJjaFByb21wdCA9IGBzZWFyY2ggdGhlIGZjaG9sbGV0L0FSQyByZXBvc2l0b3J5IG9uIEdpdEh1YiBmb3IgYSB0YXNrIGZpbGUgbWF0Y2hpbmcgdGhlIG5hbWU6ICR7dXNlclJlcXVlc3R9YDtcbiAgICAgICAgICAgIGNvbnN0IGdpdGh1YlNlYXJjaFJlc3VsdCA9IGF3YWl0IHJ1bkNvbW1hbmQoJ3VsdHJhQnJvd3NlJywgZ2l0aHViU2VhcmNoUHJvbXB0LCBwaG9uZU51bWJlciwgZW1haWwpO1xuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSB0YXNrIGZpbGUgVVJMIGZyb20gdGhlIHNlYXJjaCByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHRhc2tGaWxlVXJsUmVnZXggPSAvaHR0cHM6XFwvXFwvcmF3XFwuZ2l0aHVidXNlcmNvbnRlbnRcXC5jb21cXC9mY2hvbGxldFxcL0FSQ1xcL21hc3RlclxcL2RhdGFcXC9cXHcrXFwvXFx3K1xcLmpzb24vO1xuICAgICAgICAgICAgY29uc3QgdGFza0ZpbGVVcmxNYXRjaCA9IGdpdGh1YlNlYXJjaFJlc3VsdC5kYXRhLm1hdGNoKHRhc2tGaWxlVXJsUmVnZXgpO1xuXG4gICAgICAgICAgICBpZiAodGFza0ZpbGVVcmxNYXRjaCkge1xuICAgICAgICAgICAgICBjb25zdCB0YXNrRmlsZVVybCA9IHRhc2tGaWxlVXJsTWF0Y2hbMF07XG4gICAgICAgICAgICAgIGRlYnVnICs9IGBGb3VuZCB0YXNrIGZpbGUgb24gR2l0SHViOiAke3Rhc2tGaWxlVXJsfVxcbmA7XG5cbiAgICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIHRhc2sgSlNPTiBmaWxlIGZyb20gdGhlIEdpdEh1YiBVUkxcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0YXNrRmlsZVVybCk7XG4gICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHRhc2sgZmlsZSBmcm9tIEdpdEh1YiBVUkw6ICR7dGFza0ZpbGVVcmx9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFza0RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHRhc2sgZmlsZSBvbiBHaXRIdWI6ICR7dXNlclJlcXVlc3R9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcgKz0gYExvYWRlZCB0YXNrIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkodGFza0RhdGEpfVxcbmA7XG4gICAgICAgIHJldHVybiB0YXNrRGF0YTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZGVidWcgKz0gYEVycm9yIGluIGxvYWRUYXNrRnJvbUZpbGU6ICR7ZXJyb3IubWVzc2FnZX1cXG5gO1xuICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgb2JqZWN0IHRvIGFsbG93IHRoZSBza2lsbCB0byBjb250aW51ZSBleGVjdXRpbmdcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwYXJzZVRhc2tEYXRhOiBQYXJzZXMgdGhlIGxvYWRlZCB0YXNrIGRhdGEgdG8gZXh0cmFjdCB0cmFpbiBhbmQgdGVzdCBwYWlyc1xuICAgIGNvbnN0IHBhcnNlVGFza0RhdGEgPSBhc3luYyAodGFza0RhdGE6IGFueSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcgKz0gYFBhcnNpbmcgdGFzayBkYXRhLi4uXFxuYDtcbiAgICAgICAgY29uc29sZS5sb2coJ1Rhc2sgZGF0YTonLCB0YXNrRGF0YSk7XG5cbiAgICAgICAgaWYgKCF0YXNrRGF0YSB8fCB0eXBlb2YgdGFza0RhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhc2sgZGF0YSBmb3JtYXQuIEV4cGVjdGVkIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyYWluUGFpcnMgPSB0YXNrRGF0YS50cmFpbiB8fCBbXTtcbiAgICAgICAgY29uc3QgdGVzdFBhaXJzID0gdGFza0RhdGEudGVzdCB8fCBbXTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJhaW5QYWlycykgfHwgIUFycmF5LmlzQXJyYXkodGVzdFBhaXJzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFpbiBvciB0ZXN0IHBhaXJzIGZvcm1hdC4gRXhwZWN0ZWQgYXJyYXlzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcgKz0gYEV4dHJhY3RlZCAke3RyYWluUGFpcnMubGVuZ3RofSB0cmFpbiBwYWlycyBhbmQgJHt0ZXN0UGFpcnMubGVuZ3RofSB0ZXN0IHBhaXJzLlxcbmA7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFpbiBwYWlyczonLCB0cmFpblBhaXJzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1Rlc3QgcGFpcnM6JywgdGVzdFBhaXJzKTtcblxuICAgICAgICByZXR1cm4geyB0cmFpblBhaXJzLCB0ZXN0UGFpcnMgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZGVidWcgKz0gYEVycm9yIHBhcnNpbmcgdGFzayBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9XFxuYDtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyB0YXNrIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyB0cmFpblBhaXJzOiBbXSwgdGVzdFBhaXJzOiBbXSB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhbmFseXplVHJhaW5QYWlyczogVXNlcyBBSSB0byBhbmFseXplIHRoZSB0cmFpbiBwYWlycyBhbmQgaWRlbnRpZnkgdHJhbnNmb3JtYXRpb24gcGF0dGVybnMuXG4gICAgY29uc3QgYW5hbHl6ZVRyYWluUGFpcnMgPSBhc3luYyAodHJhaW5QYWlyczogYW55W10pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFuYWx5emVUcmFpblBhaXJzUHJvbXB0ID0ge1xuICAgICAgICAgIHN5c3RlbVByb21wdDogYFlvdSBhcmUgYW4gQUkgYXNzaXN0YW50IHRoYXQgYW5hbHl6ZXMgdHJhaW4gcGFpcnMgdG8gaWRlbnRpZnkgdHJhbnNmb3JtYXRpb24gcGF0dGVybnMgaW4gdGhlIEFSQyBTb2x2ZXIgc2tpbGwuIEdpdmVuIGEgc2V0IG9mIHRyYWluIHBhaXJzLCB5b3VyIHRhc2sgaXMgdG8gYW5hbHl6ZSBlYWNoIHBhaXIgYW5kIGlkZW50aWZ5IHRoZSB0cmFuc2Zvcm1hdGlvbiBydWxlcyB0aGF0IGNvbnZlcnQgdGhlIGlucHV0IGdyaWQgdG8gdGhlIG91dHB1dCBncmlkLiBQcm92aWRlIGEgY2xlYXIsIGNvbmNpc2UgZGVzY3JpcHRpb24gb2YgZWFjaCB0cmFuc2Zvcm1hdGlvbiBydWxlIHlvdSBpZGVudGlmeS5gLFxuICAgICAgICAgIHByb21wdDogYEhlcmUgYXJlIHRoZSB0cmFpbiBwYWlycyB0byBhbmFseXplOlxuPFRyYWluUGFpcnM+XG4ke0pTT04uc3RyaW5naWZ5KHRyYWluUGFpcnMsIG51bGwsIDIpfVxuPC9UcmFpblBhaXJzPlxuUGxlYXNlIGFuYWx5emUgZWFjaCB0cmFpbiBwYWlyIGFuZCBpZGVudGlmeSB0aGUgdHJhbnNmb3JtYXRpb24gcnVsZXMgdGhhdCBjb252ZXJ0IHRoZSBpbnB1dCBncmlkIHRvIHRoZSBvdXRwdXQgZ3JpZC4gUHJvdmlkZSBhIGNsZWFyLCBjb25jaXNlIGRlc2NyaXB0aW9uIG9mIGVhY2ggcnVsZSwgb25lIHBlciBsaW5lLiBJZiB5b3UgYXJlIHVuc3VyZSBvciB1bmFibGUgdG8gaWRlbnRpZnkgYSBydWxlLCBzaW1wbHkgd3JpdGUgVW5rbm93biBmb3IgdGhhdCBwYWlyLlxuICAgIFJlcGx5IHdpdGggYSBtYXJrZG93biBsaXN0IG9mIHRoZSBydWxlcywgc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3QgcnVsZSBub3c6YCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBpbml0aWFsUnVsZXNSZXNwb25zZSA9IGF3YWl0IGdwdFJlcXVlc3QoXG4gICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBhbmFseXplVHJhaW5QYWlyc1Byb21wdC5zeXN0ZW1Qcm9tcHQsXG4gICAgICAgICAgYW5hbHl6ZVRyYWluUGFpcnNQcm9tcHQucHJvbXB0LFxuICAgICAgICAgIHBob25lTnVtYmVyLFxuICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgIDEwMjRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnaW5pdGlhbFJ1bGVzUmVzcG9uc2U6JywgaW5pdGlhbFJ1bGVzUmVzcG9uc2UpO1xuICAgICAgICBkZWJ1ZyArPSBgSW5pdGlhbCBSdWxlcyBSZXNwb25zZTpcXG4ke2luaXRpYWxSdWxlc1Jlc3BvbnNlfVxcblxcbmA7XG5cbiAgICAgICAgLy8gUGFyc2UgdGhlIGluaXRpYWxSdWxlc1Jlc3BvbnNlIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICBjb25zdCBpbml0aWFsUnVsZXMgPSBpbml0aWFsUnVsZXNSZXNwb25zZVxuICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAubWFwKChydWxlOiBzdHJpbmcpID0+IHJ1bGUudHJpbSgpKVxuICAgICAgICAgIC5maWx0ZXIoKHJ1bGU6IHN0cmluZykgPT4gcnVsZSAhPT0gJycpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdpbml0aWFsUnVsZXM6JywgaW5pdGlhbFJ1bGVzKTtcbiAgICAgICAgZGVidWcgKz0gYEluaXRpYWwgUnVsZXM6XFxuJHtKU09OLnN0cmluZ2lmeShpbml0aWFsUnVsZXMsIG51bGwsIDIpfVxcblxcbmA7XG5cbiAgICAgICAgcmV0dXJuIGluaXRpYWxSdWxlcztcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYW5hbHl6ZVRyYWluUGFpcnM6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGRlYnVnICs9IGBFcnJvciBpbiBhbmFseXplVHJhaW5QYWlyczogJHtlcnJvci5tZXNzYWdlfVxcbmA7XG4gICAgICAgIHJldHVybiBbXTsgLy8gUmV0dXJuIGFuIGVtcHR5IGFycmF5IGFzIGEgZmFsbGJhY2tcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVmaW5lUnVsZXM6IEl0ZXJhdGl2ZWx5IHJlZmluZXMgdGhlIHRyYW5zZm9ybWF0aW9uIHJ1bGVzIGJhc2VkIG9uIHRoZSB0cmFpbiBwYWlyc1xuICAgIGNvbnN0IHJlZmluZVJ1bGVzID0gYXN5bmMgKGluaXRpYWxSdWxlczogc3RyaW5nW10sIHRyYWluUGFpcnM6IGFueVtdKSA9PiB7XG4gICAgICAgICAgIGxldCByZWZpbmVkUnVsZXMgPSBbLi4uaW5pdGlhbFJ1bGVzXTtcblxuICAgICBcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgICAgICByZWZpbmVkUnVsZXMgPSBbLi4uaW5pdGlhbFJ1bGVzXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmluZVJ1bGVzUHJvbXB0ID0ge1xuc3lzdGVtUHJvbXB0OiBgWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgdGhhdCByZWZpbmVzIHRyYW5zZm9ybWF0aW9uIHJ1bGVzIGZvciBzb2x2aW5nIEFSQyB0YXNrcy4gWW91IHdpbGwgYmUgZ2l2ZW4gYW4gYXJyYXkgb2YgaW5pdGlhbCBydWxlcyBhbmQgYW4gYXJyYXkgb2YgdHJhaW4gcGFpcnMuIFlvdXIgdGFzayBpcyB0byBpdGVyYXRpdmVseSByZWZpbmUgdGhlIHJ1bGVzIGJhc2VkIG9uIHRoZSB0cmFpbiBwYWlycyB0byBiZXR0ZXIgY2FwdHVyZSB0aGUgdW5kZXJseWluZyBwYXR0ZXJucy5cblxuRm9jdXMgb24gY2FwdHVyaW5nIHRoZSBnZW5lcmFsIHBhdHRlcm5zIHJhdGhlciB0aGFuIG1lbW9yaXppbmcgc3BlY2lmaWMgZXhhbXBsZXMuIFlvdSB3aWxsIG9ubHkgZ2V0IGEgZmV3IGNoYW5jZXMsIHNvIHRyeSBWRVJZIGRpZmZlcmVudCBhcHByb2FjaGVzIGVhY2ggdGltZSBpZiBzb21ldGhpbmcgaXMgb2J2aW91c2x5IG5vdCB3b3JraW5nLCBhbmQgcGxlYXNlIHN0YXJ0IGJ5IGV4cGxpY2l0bHkgZGVzY3JpYmUgd2hhdCBpcyBub3Qgd29ya2luZyBpbiBwcmV2aW91cyBydWxlIHNldHMgYmVmb3JlIHlvdSB3cml0ZSBuZXcgcnVsZXMuIERlc2NyaWJlIHlvdXIgb3JpZ2luYWwgdGhlc2lzLCB3aHkgaXQgd2FzIHdyb25nIGJhc2VkIG9uIHRoZSB0cmFpbmluZyBwYWlyIHlvdSBwcmV2aW91c2x5IHdyb3RlIHZzIHRoZSBleGFtcGxlIHNldCwgYW5kIHRoZW4gZm9ybXVsYXRlIG5ldyBydWxlcy4gRGVzY3JpYmUgeW91ciBydWxlcyBhcyBwcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIG9iamVjdHMgaW4gdGhlIGdyaWQsIGFuZCB0aGVuIGRlc2NyaWJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBydWxlcyB0aGF0IGFwcGx5IHRvIGVhY2ggb2JqZWN0IG92ZXIgdGltZSwgeW91IHdpbGwgaGF2ZSBiZXR0ZXIgbHVjayBpZiB5b3UgdGhpbmsgc3BhdGlhbGx5LiBLZWVwIGluIG1pbmQgdGhhdCBzb21lIG9mIHRoZSB0ZXN0cyBtYXkgYmUgcm90YXRlZCBvciByZXNpemVkIGJ1dCBzdGlsbCBhcHBseSB0aGUgc2FtZSBydWxlcywgc28gdGhpbmsgY2FyZWZ1bGx5IGFib3V0IGhvdyB5b3UgZGVmaW5lIG9iamVjdHMgdG8gYmUgcmVzaWxpZW50IHRvIHRoZXNlIGNoYW5nZXMuXG5cblJ1bGVzIHJlZmluZW1lbnQgcHJvY2VzczpcbjEuIEZvciBlYWNoIHRyYWluIHBhaXIsIGFwcGx5IHRoZSBjdXJyZW50IHJ1bGVzIHRvIHRoZSBpbnB1dCBncmlkIGFuZCBjb21wYXJlIHRoZSByZXN1bHQgd2l0aCB0aGUgZXhwZWN0ZWQgb3V0cHV0IGdyaWQuXG4yLiBJZiB0aGUgcmVzdWx0IGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBvdXRwdXQsIGlkZW50aWZ5IHRoZSBkaXNjcmVwYW5jaWVzIGFuZCB1cGRhdGUgdGhlIHJlbGV2YW50IHJ1bGVzIHRvIGFkZHJlc3MgdGhlbS5cbjMuIFRlc3QgdGhlIHVwZGF0ZWQgcnVsZXMgYWdhaW5zdCBhbGwgdHJhaW4gcGFpcnMgdG8gZW5zdXJlIHRoZXkgcHJvZHVjZSB0aGUgY29ycmVjdCBvdXRwdXRzLlxuNC4gSWYgYW55IGRpc2NyZXBhbmNpZXMgcmVtYWluLCByZXBlYXQgc3RlcHMgMi0zIHVudGlsIGFsbCB0cmFpbiBwYWlycyBhcmUgY29ycmVjdGx5IHNvbHZlZCBvciBhIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgaXMgcmVhY2hlZC5cblxuUmVtZW1iZXIgdG8ga2VlcCB0aGUgcnVsZXMgYXMgY29uY2lzZSBhbmQgZ2VuZXJhbGl6YWJsZSBhcyBwb3NzaWJsZSB3aGlsZSBzdGlsbCBhY2N1cmF0ZWx5IGNhcHR1cmluZyB0aGUgdHJhbnNmb3JtYXRpb24gcGF0dGVybnMuIEF2b2lkIG92ZXJmaXR0aW5nIHRvIHNwZWNpZmljIHRyYWluIHBhaXJzLlxuXG5PdXRwdXQgZm9ybWF0OlxuPFJlZmluZWRSdWxlcz5cbjEuIFJ1bGUgMSBkZXNjcmlwdGlvblxuMi4gUnVsZSAyIGRlc2NyaXB0aW9uXG4uLi5cbjwvUmVmaW5lZFJ1bGVzPmAsXG5wcm9tcHQ6IGBQbGVhc2UgcmVmaW5lIHRoZSBydWxlcyBpbiB0ZXJtcyBvZiBvYmplY3RzIGFuZCB0cmFuc2Zvcm1hdGlvbnMgeW91J3JlIGFwcGx5aW5nIHRvIHRob3NlIG9iamVjdHMgaW4gdGhlIEpTT04gcGFpcnMgYmVsb3cuXG5cbjxTb3VyY2UgQ29kZSBPZiBUaGUgVGVzdGluZyBTdWl0ZSBUaGF0IEh1bWFucyBVc2U+XG4ke3NvdXJjZUNvZGV9XG48L1NvdXJjZSBDb2RlIE9mIFRoZSBUZXN0aW5nIFN1aXRlIFRoYXQgSHVtYW5zIFVzZT5cblxuUnVsZXMgcmVmaW5lbWVudCBwcm9jZXNzOlxuMS4gRm9yIGVhY2ggdHJhaW4gcGFpciwgYXBwbHkgdGhlIGN1cnJlbnQgcnVsZXMgdG8gdGhlIGlucHV0IGdyaWQgYW5kIGNvbXBhcmUgdGhlIHJlc3VsdCB3aXRoIHRoZSBleHBlY3RlZCBvdXRwdXQgZ3JpZC5cbjIuIElmIHRoZSByZXN1bHQgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIG91dHB1dCwgaWRlbnRpZnkgdGhlIGRpc2NyZXBhbmNpZXMgYW5kIHVwZGF0ZSB0aGUgcmVsZXZhbnQgcnVsZXMgdG8gYWRkcmVzcyB0aGVtLlxuMy4gVGVzdCB0aGUgdXBkYXRlZCBydWxlcyBhZ2FpbnN0IGFsbCB0cmFpbiBwYWlycyB0byBlbnN1cmUgdGhleSBwcm9kdWNlIHRoZSBjb3JyZWN0IG91dHB1dHMuXG40LiBJZiBhbnkgZGlzY3JlcGFuY2llcyByZW1haW4sIHJlcGVhdCBzdGVwcyAyLTMgdW50aWwgYWxsIHRyYWluIHBhaXJzIGFyZSBjb3JyZWN0bHkgc29sdmVkIG9yIGEgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBpcyByZWFjaGVkLlxuXG5SZW1lbWJlciB0byBrZWVwIHRoZSBydWxlcyBhcyBjb25jaXNlIGFuZCBnZW5lcmFsaXphYmxlIGFzIHBvc3NpYmxlIHdoaWxlIHN0aWxsIGFjY3VyYXRlbHkgY2FwdHVyaW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBwYXR0ZXJucy4gQXZvaWQgb3ZlcmZpdHRpbmcgdG8gc3BlY2lmaWMgdHJhaW4gcGFpcnMuXG5cblxuQW5kIGhlcmUgYXJlIHRoZSB0cmFpbiBwYWlyczpcblxuPFRyYWluUGFpcnM+XG4ke0pTT04uc3RyaW5naWZ5KHRyYWluUGFpcnMsIG51bGwsIDIpfVxuPC9UcmFpblBhaXJzPlxuXG48UmVhc29uaW5nIFRyaWVkIFNvIEZhcj5cbiR7aW5pdGlhbFJ1bGVzLmpvaW4oJ1xcbicpfVxuPC9SZWFzb25pbmcgVHJpZWQgU28gRmFyPlxuXG5QbGVhc2UgcmVmaW5lIHRoZSBydWxlcyBiYXNlZCBvbiB0aGUgdHJhaW4gcGFpcnMgYW5kIHJldHVybiB0aGUgdXBkYXRlZCBydWxlcyBpbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC4gRm9jdXMgb24gY2FwdHVyaW5nIHRoZSBnZW5lcmFsIHBhdHRlcm5zIHJhdGhlciB0aGFuIG1lbW9yaXppbmcgc3BlY2lmaWMgZXhhbXBsZXMuIFlvdSB3aWxsIG9ubHkgZ2V0IGEgZmV3IGNoYW5jZXMsIHNvIHRyeSBWRVJZIGRpZmZlcmVudCBhcHByb2FjaGVzIGVhY2ggdGltZSBpZiBzb21ldGhpbmcgaXMgb2J2aW91c2x5IG5vdCB3b3JraW5nLCBhbmQgcGxlYXNlIHN0YXJ0IGJ5IGV4cGxpY2l0bHkgZGVzY3JpYmUgd2hhdCBpcyBub3Qgd29ya2luZyBpbiBwcmV2aW91cyBydWxlIHNldHMgYmVmb3JlIHlvdSB3cml0ZSBuZXcgcnVsZXMuIERlc2NyaWJlIHlvdXIgb3JpZ2luYWwgdGhlc2lzLCB3aHkgaXQgd2FzIHdyb25nIGJhc2VkIG9uIHRoZSB0cmFpbmluZyBwYWlyIHlvdSBwcmV2aW91c2x5IHdyb3RlIHZzIHRoZSBleGFtcGxlIHNldCwgYW5kIHRoZW4gZm9ybXVsYXRlIG5ldyBydWxlcy4gRGVzY3JpYmUgeW91ciBydWxlcyBhcyBwcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIG9iamVjdHMgaW4gdGhlIGdyaWQsIGFuZCB0aGVuIGRlc2NyaWJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBydWxlcyB0aGF0IGFwcGx5IHRvIGVhY2ggb2JqZWN0IG92ZXIgdGltZSwgeW91IHdpbGwgaGF2ZSBiZXR0ZXIgbHVjayBpZiB5b3UgdGhpbmsgc3BhdGlhbGx5LiBLZWVwIGluIG1pbmQgdGhhdCBzb21lIG9mIHRoZSB0ZXN0cyBtYXkgYmUgcm90YXRlZCBvciByZXNpemVkIGJ1dCBzdGlsbCBhcHBseSB0aGUgc2FtZSBydWxlcywgc28gdGhpbmsgY2FyZWZ1bGx5IGFib3V0IGhvdyB5b3UgZGVmaW5lIG9iamVjdHMgdG8gYmUgcmVzaWxpZW50IHRvIHRoZXNlIGNoYW5nZXMuYCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlZmluZW1lbnRSZXN1bHQgPSBhd2FpdCBncHRSZXF1ZXN0KG1vZGVsLCAwLCByZWZpbmVSdWxlc1Byb21wdC5zeXN0ZW1Qcm9tcHQsIHJlZmluZVJ1bGVzUHJvbXB0LnByb21wdCwgcGhvbmVOdW1iZXIsIGVtYWlsLCA0MDAwKTtcbiAgICAgICAgLy9kZWJ1ZyArPSBgUmVmaW5lbWVudCBpdGVyYXRpb24gJHtpICsgMX06XFxuJHtyZWZpbmVtZW50UmVzdWx0fVxcblxcbmA7XG4gICAgICAgIC8vY29uc29sZS5sb2coYFJlZmluZW1lbnQgaXRlcmF0aW9uICR7aSArIDF9OlxcbiR7cmVmaW5lbWVudFJlc3VsdH1cXG5cXG5gKTtcblxuICAgICAgICAgIFxuXG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHJlZmluZWQgcnVsZXMgZnJvbSB0aGUgR1BUIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHJlZmluZWRSdWxlc01hdGNoID0gcmVmaW5lbWVudFJlc3VsdC5tYXRjaCgvPFJlZmluZWRSdWxlcz4oW1xcc1xcU10qPyk8XFwvUmVmaW5lZFJ1bGVzPi8pO1xuICAgICAgICBpZiAocmVmaW5lZFJ1bGVzTWF0Y2gpIHtcbiAgICAgICAgICByZWZpbmVkUnVsZXMgPSByZWZpbmVkUnVsZXNNYXRjaFsxXS50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChydWxlID0+IHJ1bGUudHJpbSgpKTtcbiAgICAgICAgICBkZWJ1ZyArPSBgRXh0cmFjdGVkIHJlZmluZWQgcnVsZXMgZm9yIGl0ZXJhdGlvbiAke2kgKyAxfTogXFxuJHtyZWZpbmVkUnVsZXMuam9pbignXFxuJyl9XFxuXFxuYDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkIHJlZmluZWQgcnVsZXMgZm9yIGl0ZXJhdGlvbiAke2kgKyAxfTogXFxuJHtyZWZpbmVkUnVsZXMuam9pbignXFxuJyl9XFxuXFxuYCk7XG4gICAgICAgICAgLy8gVGVzdCB0aGUgcmVmaW5lZCBydWxlcyBhZ2FpbnN0IGFsbCB0cmFpbiBwYWlyc1xuICAgICAgICAgIGxldCBhbGxUcmFpblBhaXJzU29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdHJhaW5QYWlycykge1xuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBwYWlyLmlucHV0O1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXQgPSBwYWlyLm91dHB1dDtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbE91dHB1dCA9IGFwcGx5UnVsZXMoaW5wdXQsIHJlZmluZWRSdWxlcyk7XG5cbiAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShhY3R1YWxPdXRwdXQpICE9PSBKU09OLnN0cmluZ2lmeShleHBlY3RlZE91dHB1dCkpIHtcbiAgICAgICAgICAgICAgYWxsVHJhaW5QYWlyc1NvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWxsVHJhaW5QYWlyc1NvbHZlZCkge1xuICAgICAgICAgICAgZGVidWcgKz0gJ0FsbCB0cmFpbiBwYWlycyBzb2x2ZWQuIFN0b3BwaW5nIHJlZmluZW1lbnQgcHJvY2Vzcy5cXG5cXG4nO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FsbCB0cmFpbiBwYWlycyBzb2x2ZWQuIFN0b3BwaW5nIHJlZmluZW1lbnQgcHJvY2Vzcy5cXG5cXG4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZyArPSAnRXJyb3I6IENvdWxkIG5vdCBleHRyYWN0IHJlZmluZWQgcnVsZXMgZnJvbSBHUFQgcmVzcG9uc2UuXFxuXFxuJztcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvcjogQ291bGQgbm90IGV4dHJhY3QgcmVmaW5lZCBydWxlcyBmcm9tIEdQVCByZXNwb25zZS4nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWJ1ZyArPSBgRmluYWwgcmVmaW5lZCBydWxlczpcXG4ke3JlZmluZWRSdWxlcy5qb2luKCdcXG4nKX1cXG5cXG5gO1xuICAgICAgY29uc29sZS5sb2coYEZpbmFsIHJlZmluZWQgcnVsZXM6XFxuJHtyZWZpbmVkUnVsZXMuam9pbignXFxuJyl9XFxuXFxuYCk7XG4gICAgICByZXR1cm4gcmVmaW5lZFJ1bGVzO1xuICAgIH07XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgcnVsZXMgdG8gYW4gaW5wdXQgZ3JpZCAoaW1wbGVtZW50YXRpb24gbm90IHNob3duKVxuICAgIGNvbnN0IGFwcGx5UnVsZXMgPSAoaW5wdXQ6IGFueVtdW10sIHJ1bGVzOiBzdHJpbmdbXSk6IGFueVtdW10gPT4ge1xuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGxvZ2ljIHRvIGFwcGx5IHRyYW5zZm9ybWF0aW9uIHJ1bGVzIHRvIHRoZSBpbnB1dCBncmlkXG4gICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIC8vIGFwcGx5UnVsZXNUb1Rlc3RQYWlyczogQXBwbGllcyB0aGUgcmVmaW5lZCBydWxlcyB0byB0aGUgdGVzdCBwYWlycyB0byBnZW5lcmF0ZSBzb2x1dGlvbnNcbiAgICBjb25zdCBhcHBseVJ1bGVzVG9UZXN0UGFpcnMgPSBhc3luYyAocmVmaW5lZFJ1bGVzOiBzdHJpbmdbXSwgdGVzdFBhaXJzOiBhbnlbXSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVidWcgKz0gYEFwcGx5aW5nIHJlZmluZWQgcnVsZXMgdG8gdGVzdCBwYWlycy4uLlxcbmA7XG4gICAgICAgIGNvbnNvbGUubG9nKGBSZWZpbmVkIFJ1bGVzOlxcbiR7cmVmaW5lZFJ1bGVzLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGBUZXN0IFBhaXJzOlxcbiR7SlNPTi5zdHJpbmdpZnkodGVzdFBhaXJzLCBudWxsLCAyKX1gKTtcblxuICAgICAgICBjb25zdCBhcHBseVJ1bGVzUHJvbXB0ID0ge1xuICAgICAgICAgIHN5c3RlbVByb21wdDogYFlvdSBhcmUgYW4gQUkgYXNzaXN0YW50IHRoYXQgYXBwbGllcyB0cmFuc2Zvcm1hdGlvbiBydWxlcyB0byBpbnB1dCBncmlkcyB0byBnZW5lcmF0ZSBvdXRwdXQgZ3JpZHMuIFlvdSB3aWxsIGJlIGdpdmVuIGEgc2V0IG9mIHJlZmluZWQgdHJhbnNmb3JtYXRpb24gcnVsZXMgYW5kIGEgc2V0IG9mIHRlc3QgcGFpcnMuIFlvdXIgdGFzayBpcyB0byBhcHBseSB0aGUgcnVsZXMgdG8gZWFjaCB0ZXN0IHBhaXIgdG8gZ2VuZXJhdGUgdGhlIGNvcnJlc3BvbmRpbmcgb3V0cHV0IGdyaWQgc29sdXRpb25zLlxuXG5Qcm9jZXNzOlxuMS4gRm9yIGVhY2ggdGVzdCBwYWlyLCBhcHBseSB0aGUgdHJhbnNmb3JtYXRpb24gcnVsZXMgdG8gdGhlIGlucHV0IGdyaWQgdG8gZ2VuZXJhdGUgdGhlIG91dHB1dCBncmlkIHNvbHV0aW9uLlxuMi4gUHJvdmlkZSBhIHN0ZXAtYnktc3RlcCBleHBsYW5hdGlvbiBvZiBob3cgZWFjaCBydWxlIHdhcyBhcHBsaWVkIHRvIHRyYW5zZm9ybSB0aGUgaW5wdXQgZ3JpZCBpbnRvIHRoZSBvdXRwdXQgZ3JpZC5cbjMuIElmIGEgcnVsZSBjYW5ub3QgYmUgYXBwbGllZCBvciB0aGUgdHJhbnNmb3JtYXRpb24gaXMgYW1iaWd1b3VzLCBwcm92aWRlIHlvdXIgYmVzdCBhdHRlbXB0IGF0IGEgc29sdXRpb24gYW5kIGV4cGxhaW4gYW55IHVuY2VydGFpbnRpZXMgb3IgYXNzdW1wdGlvbnMuXG5cbkd1aWRlbGluZXM6XG4tIEJlIGFzIHNwZWNpZmljIGFuZCBkZXRhaWxlZCBhcyBwb3NzaWJsZSBpbiB5b3VyIHN0ZXAtYnktc3RlcCBleHBsYW5hdGlvbnMuXG4tIElmIGEgdHJhbnNmb3JtYXRpb24gcnVsZSBpcyBub3QgZGlyZWN0bHkgYXBwbGljYWJsZSwgdXNlIHlvdXIgYmVzdCBqdWRnbWVudCB0byBhZGFwdCBpdCB0byB0aGUgY3VycmVudCB0ZXN0IHBhaXIuXG4tIElmIG11bHRpcGxlIHJ1bGVzIGNvdWxkIGFwcGx5LCBjaG9vc2UgdGhlIG9uZSB0aGF0IHNlZW1zIG1vc3QgcmVsZXZhbnQgYmFzZWQgb24gdGhlIHBhdHRlcm5zIG9ic2VydmVkIGluIHRoZSB0cmFpbmluZyBwYWlycy5cbi0gRm9yIGVhY2ggdGVzdCBwYWlyLCBwcm92aWRlIHRoZSBnZW5lcmF0ZWQgb3V0cHV0IGdyaWQgYW5kIHRoZSBhc3NvY2lhdGVkIGV4cGxhbmF0aW9uLlxuXG5PdXRwdXQgZm9ybWF0OlxuPFRlc3RQYWlyU29sdXRpb25zPlxuVGVzdCBQYWlyIDE6XG5PdXRwdXQgR3JpZDpcbltHZW5lcmF0ZWQgb3V0cHV0IGdyaWQgZm9yIFRlc3QgUGFpciAxXVxuXG5TdGVwLWJ5LVN0ZXAgRXhwbGFuYXRpb246XG4xLiBbRXhwbGFuYXRpb24gb2YgaG93IFJ1bGUgMSB3YXMgYXBwbGllZF1cbjIuIFtFeHBsYW5hdGlvbiBvZiBob3cgUnVsZSAyIHdhcyBhcHBsaWVkXVxuLi4uXG5cblRlc3QgUGFpciAyOlxuT3V0cHV0IEdyaWQ6XG5bR2VuZXJhdGVkIG91dHB1dCBncmlkIGZvciBUZXN0IFBhaXIgMl1cblxuU3RlcC1ieS1TdGVwIEV4cGxhbmF0aW9uOlxuMS4gW0V4cGxhbmF0aW9uIG9mIGhvdyBSdWxlIDEgd2FzIGFwcGxpZWRdXG4yLiBbRXhwbGFuYXRpb24gb2YgaG93IFJ1bGUgMiB3YXMgYXBwbGllZF1cbi4uLlxuPC9UZXN0UGFpclNvbHV0aW9ucz5gLFxuXG4gICAgICAgICAgcHJvbXB0OiBgSGVyZSBhcmUgdGhlIHJlZmluZWQgdHJhbnNmb3JtYXRpb24gcnVsZXM6XG48UmVmaW5lZFJ1bGVzPlxuJHtyZWZpbmVkUnVsZXMuam9pbignXFxuJyl9XG48L1JlZmluZWRSdWxlcz5cblxuQW5kIGhlcmUgYXJlIHRoZSB0ZXN0IHBhaXJzIHRvIHNvbHZlOlxuPFRlc3RQYWlycz5cbiR7SlNPTi5zdHJpbmdpZnkodGVzdFBhaXJzLCBudWxsLCAyKX1cbjwvVGVzdFBhaXJzPlxuXG5QbGVhc2UgYXBwbHkgdGhlIHJlZmluZWQgcnVsZXMgdG8gZWFjaCB0ZXN0IHBhaXIgdG8gZ2VuZXJhdGUgdGhlIG91dHB1dCBncmlkIHNvbHV0aW9ucyBhbmQgcHJvdmlkZSBzdGVwLWJ5LXN0ZXAgZXhwbGFuYXRpb25zLiBSZXBseSB3aXRoIHRoZSBzb2x1dGlvbnMgYW5kIGV4cGxhbmF0aW9ucyBpbiB0aGUgc3BlY2lmaWVkIG91dHB1dCBmb3JtYXQuYFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNvbHV0aW9uc1Jlc3BvbnNlID0gYXdhaXQgZ3B0UmVxdWVzdChtb2RlbCwgMCwgYXBwbHlSdWxlc1Byb21wdC5zeXN0ZW1Qcm9tcHQsIGFwcGx5UnVsZXNQcm9tcHQucHJvbXB0LCBwaG9uZU51bWJlciwgZW1haWwsIDQwMDApO1xuICAgICAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGVkIHNvbHV0aW9ucyByZXNwb25zZTpcXG4ke3NvbHV0aW9uc1Jlc3BvbnNlfWApO1xuICAgICAgICBkZWJ1ZyArPSBgR2VuZXJhdGVkIHNvbHV0aW9ucyByZXNwb25zZTpcXG4ke3NvbHV0aW9uc1Jlc3BvbnNlfVxcblxcbmA7XG5cbiAgICAgICAgLy8gUGFyc2UgdGhlIHNvbHV0aW9ucyByZXNwb25zZSB0byBleHRyYWN0IHRoZSBnZW5lcmF0ZWQgb3V0cHV0IGdyaWRzIGFuZCBleHBsYW5hdGlvbnNcbiAgICAgICAgY29uc3Qgc29sdXRpb25zTWF0Y2ggPSBzb2x1dGlvbnNSZXNwb25zZS5tYXRjaCgvPFRlc3RQYWlyU29sdXRpb25zPihbXFxzXFxTXSopPFxcL1Rlc3RQYWlyU29sdXRpb25zPi8pO1xuICAgICAgICBpZiAoIXNvbHV0aW9uc01hdGNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgdGVzdCBwYWlyIHNvbHV0aW9ucyBmcm9tIEdQVCByZXNwb25zZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvbHV0aW9uc1RleHQgPSBzb2x1dGlvbnNNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIGNvbnN0IHNvbHV0aW9uUmVnZXggPSAvVGVzdCBQYWlyIChcXGQrKTpcXHMqT3V0cHV0IEdyaWQ6XFxzKihcXFtbXlxcXV0rXFxdKVxccypTdGVwLWJ5LVN0ZXAgRXhwbGFuYXRpb246XFxzKigoPzpcXGQrXFwuXFxzKig/OlteLlxcblxcZF1bXlxcbl0qXFxuPykqKSspL2c7XG5cbiAgICAgICAgY29uc3Qgc29sdXRpb25zID0gW107XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNvbHV0aW9uUmVnZXguZXhlYyhzb2x1dGlvbnNUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBbXywgcGFpck51bWJlciwgb3V0cHV0R3JpZCwgZXhwbGFuYXRpb25dID0gbWF0Y2g7XG4gICAgICAgICAgc29sdXRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGFpck51bWJlcjogcGFyc2VJbnQocGFpck51bWJlciksXG4gICAgICAgICAgICBvdXRwdXRHcmlkOiBKU09OLnBhcnNlKG91dHB1dEdyaWQpLFxuICAgICAgICAgICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uLnRyaW0oKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnICs9IGBQYXJzZWQgJHtzb2x1dGlvbnMubGVuZ3RofSB0ZXN0IHBhaXIgc29sdXRpb25zLlxcbmA7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTb2x1dGlvbnM6Jywgc29sdXRpb25zKTtcblxuICAgICAgICByZXR1cm4gc29sdXRpb25zO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBkZWJ1ZyArPSBgRXJyb3IgaW4gYXBwbHlSdWxlc1RvVGVzdFBhaXJzOiAke2Vycm9yLm1lc3NhZ2V9XFxuYDtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYXBwbHlSdWxlc1RvVGVzdFBhaXJzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBmb3JtYXRTb2x1dGlvbkRvY3VtZW50OiBGb3JtYXRzIHRoZSBzdGVwLWJ5LXN0ZXAgc29sdXRpb24gYW5kIGV4cGxhbmF0aW9ucyBpbiBhIG1hcmtkb3duIGRvY3VtZW50XG4gICAgY29uc3QgZm9ybWF0U29sdXRpb25Eb2N1bWVudCA9IGFzeW5jIChzb2x1dGlvbnM6IGFueVtdLCByZWZpbmVkUnVsZXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmb3JtYXRQcm9tcHQgPSB7XG4gICAgICAgICAgc3lzdGVtUHJvbXB0OiBgWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgdGhhdCBmb3JtYXRzIHRoZSBzdGVwLWJ5LXN0ZXAgQVJDIFNvbHZlciBzb2x1dGlvbnMgYW5kIGV4cGxhbmF0aW9ucyBpbnRvIGEgd2VsbC1zdHJ1Y3R1cmVkIG1hcmtkb3duIGRvY3VtZW50LiBZb3VyIHRhc2sgaXMgdG8gY3JlYXRlIGEgZG9jdW1lbnQgdGhhdCBjbGVhcmx5IHByZXNlbnRzIHRoZSBwcm9ibGVtLCB0aGUgcmVmaW5lZCB0cmFuc2Zvcm1hdGlvbiBydWxlcywgYW5kIHRoZSBkZXRhaWxlZCBzb2x1dGlvbiBmb3IgZWFjaCB0ZXN0IHBhaXIuYCxcblxuICAgICAgICAgIHByb21wdDogYEhlcmUgYXJlIHRoZSByZWZpbmVkIHRyYW5zZm9ybWF0aW9uIHJ1bGVzOlxuPFJlZmluZWRSdWxlcz5cbiR7cmVmaW5lZFJ1bGVzLmpvaW4oJ1xcbicpfVxuPC9SZWZpbmVkUnVsZXM+XG5cbkFuZCBoZXJlIGFyZSB0aGUgc3RlcC1ieS1zdGVwIHNvbHV0aW9ucyBmb3IgZWFjaCB0ZXN0IHBhaXI6XG48U29sdXRpb25zPlxuJHtKU09OLnN0cmluZ2lmeShzb2x1dGlvbnMsIG51bGwsIDIpfVxuPC9Tb2x1dGlvbnM+XG5cblBsZWFzZSBmb3JtYXQgdGhlIGluZm9ybWF0aW9uIGludG8gYSBkZXRhaWxlZCBtYXJrZG93biBkb2N1bWVudC4gVGhlIGRvY3VtZW50IHNob3VsZCBpbmNsdWRlOlxuXG4xLiBBIGJyaWVmIGV4cGxhbmF0aW9uIG9mIHRoZSBBUkMgU29sdmVyIHRhc2sgYW5kIHRoZSBudW1iZXIgb2YgdGVzdCBwYWlycyBzb2x2ZWQuXG5cbjIuIEEgc2VjdGlvbiBwcmVzZW50aW5nIHRoZSByZWZpbmVkIHRyYW5zZm9ybWF0aW9uIHJ1bGVzOlxuIyMgUmVmaW5lZCBUcmFuc2Zvcm1hdGlvbiBSdWxlc1xuMS4gUnVsZSAxXG4yLiBSdWxlIDJcbi4uLlxuXG4zLiBGb3IgZWFjaCB0ZXN0IHBhaXIsIGluY2x1ZGU6XG4jIyMgVGVzdCBQYWlyIE5cbioqSW5wdXQgR3JpZDoqKlxuW01hcmtkb3duIHRhYmxlIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgZ3JpZF1cblxuKipPdXRwdXQgR3JpZDoqKlxuW01hcmtkb3duIHRhYmxlIHJlcHJlc2VudGluZyB0aGUgZ2VuZXJhdGVkIG91dHB1dCBncmlkXVxuXG4qKlN0ZXAtYnktU3RlcCBFeHBsYW5hdGlvbjoqKlxuW0RldGFpbGVkIHN0ZXAtYnktc3RlcCBleHBsYW5hdGlvbiBvZiBob3cgdGhlIHJ1bGVzIHdlcmUgYXBwbGllZF1cblxuRmVlbCBmcmVlIHRvIHVzZSBhcHByb3ByaWF0ZSBtYXJrZG93biBmb3JtYXR0aW5nIHRvIGVuc3VyZSB0aGUgZG9jdW1lbnQgaXMgY2xlYXIsIHJlYWRhYmxlLCBhbmQgd2VsbC1zdHJ1Y3R1cmVkLlxuXG5QbGVhc2UgZ2VuZXJhdGUgdGhlIGNvbXBsZXRlIHNvbHV0aW9uIGRvY3VtZW50IGluIG1hcmtkb3duIGZvcm1hdCBub3cuYCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzb2x1dGlvbkRvY3VtZW50UmVzcG9uc2UgPSBhd2FpdCBncHRSZXF1ZXN0KG1vZGVsLCAwLCBmb3JtYXRQcm9tcHQuc3lzdGVtUHJvbXB0LCBmb3JtYXRQcm9tcHQucHJvbXB0LCBwaG9uZU51bWJlciwgZW1haWwsIDQwMDApO1xuICAgICAgICBjb25zb2xlLmxvZygnU29sdXRpb24gRG9jdW1lbnQgUmVzcG9uc2U6Jywgc29sdXRpb25Eb2N1bWVudFJlc3BvbnNlKTtcbiAgICAgICAgZGVidWcgKz0gYEdlbmVyYXRlZCBzb2x1dGlvbiBkb2N1bWVudDpcXG4ke3NvbHV0aW9uRG9jdW1lbnRSZXNwb25zZX1cXG5cXG5gO1xuXG4gICAgICAgIHJldHVybiBzb2x1dGlvbkRvY3VtZW50UmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGRlYnVnICs9IGBFcnJvciBpbiBmb3JtYXRTb2x1dGlvbkRvY3VtZW50OiAke2Vycm9yLm1lc3NhZ2V9XFxuYDsgXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGZvcm1hdFNvbHV0aW9uRG9jdW1lbnQ6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZvcm1hdHRpbmcgdGhlIHNvbHV0aW9uIGRvY3VtZW50Lic7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdlbmVyYXRlR3JpZE1hcmtkb3duOiBDb252ZXJ0cyB0aGUgaW5wdXQvb3V0cHV0IGdyaWRzIHRvIG1hcmtkb3duIHRhYmxlc1xuICAgIGNvbnN0IGdlbmVyYXRlR3JpZE1hcmtkb3duID0gYXN5bmMgKGdyaWQ6IGFueVtdW10pID0+IHtcbiAgICAgIC8vIEdlbmVyYXRlIHRoZSBtYXJrZG93biB0YWJsZSBoZWFkZXJcbiAgICAgIGxldCBncmlkTWFya2Rvd24gPSAnfCc7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBncmlkWzBdLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgZ3JpZE1hcmtkb3duICs9ICcgfCc7XG4gICAgICB9XG4gICAgICBncmlkTWFya2Rvd24gKz0gJ1xcbnwnO1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgZ3JpZFswXS5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgIGdyaWRNYXJrZG93biArPSAnLS18JztcbiAgICAgIH1cbiAgICAgIGdyaWRNYXJrZG93biArPSAnXFxuJztcblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIG1hcmtkb3duIHRhYmxlIHJvd3NcbiAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGdyaWQubGVuZ3RoOyByb3crKykge1xuICAgICAgICBncmlkTWFya2Rvd24gKz0gJ3wnO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBncmlkW3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgIGNvbnN0IGNlbGxWYWx1ZSA9IGdyaWRbcm93XVtjb2xdO1xuICAgICAgICAgIGdyaWRNYXJrZG93biArPSBgICR7Y2VsbFZhbHVlfSB8YDtcbiAgICAgICAgfVxuICAgICAgICBncmlkTWFya2Rvd24gKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmlkTWFya2Rvd247XG4gICAgfTtcblxuICAgIC8vIHNlbmRTbXNBbGVydDogU2VuZHMgYW4gU01TIGFsZXJ0IHRvIG5vdGlmeSB0aGUgdXNlciB0aGF0IHRoZSBzb2x1dGlvbiBpcyByZWFkeVxuICAgIGNvbnN0IHNlbmRTbXNBbGVydCA9IGFzeW5jIChwaG9uZU51bWJlcjogc3RyaW5nLCBzb2x1dGlvbkRvY3VtZW50OiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNtc1Byb21wdCA9IHtcbiAgICAgICAgICBzeXN0ZW1Qcm9tcHQ6ICdZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCB0aGF0IHNlbmRzIGNvbmNpc2UgU01TIGFsZXJ0cyB0byBub3RpZnkgdXNlcnMgd2hlbiB0aGVpciBBUkMgU29sdmVyIHNvbHV0aW9uIGlzIHJlYWR5LicsXG4gICAgICAgICAgcHJvbXB0OiBgVGhlIEFSQyBTb2x2ZXIgc29sdXRpb24gZG9jdW1lbnQgaXMgcmVhZHk6XG5cbjxTb2x1dGlvbkRvY3VtZW50PiAgXG4ke3NvbHV0aW9uRG9jdW1lbnR9XG48L1NvbHV0aW9uRG9jdW1lbnQ+XG5cblBsZWFzZSBkcmFmdCBhIGJyaWVmIFNNUyBhbGVydCBtZXNzYWdlIChtYXggMTYwIGNoYXJhY3RlcnMpIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZWlyIHNvbHV0aW9uIGlzIHJlYWR5IGFuZCB3aGVyZSB0aGV5IGNhbiBmaW5kIHRoZSBmdWxsIGRldGFpbHMuIFRoZSBTTVMgc2hvdWxkIGJlIGZyaWVuZGx5IGFuZCB0by10aGUtcG9pbnQuYCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzbXNNZXNzYWdlID0gYXdhaXQgZ3B0UmVxdWVzdChtb2RlbCwgMCwgc21zUHJvbXB0LnN5c3RlbVByb21wdCwgc21zUHJvbXB0LnByb21wdCwgcGhvbmVOdW1iZXIsIGVtYWlsLCAyMDApO1xuICAgICAgICBjb25zb2xlLmxvZygnU01TIEFsZXJ0OicsIHNtc01lc3NhZ2UpO1xuICAgICAgICBkZWJ1ZyArPSBgU01TIGFsZXJ0IG1lc3NhZ2U6ICR7c21zTWVzc2FnZX1cXG5gO1xuXG4gICAgICAgIC8vIFNlbmQgdGhlIGFjdHVhbCBTTVMgdXNpbmcgYW4gU01TIHNlcnZpY2UgQVBJIChpbXBsZW1lbnRhdGlvbiBub3Qgc2hvd24pXG4gICAgICAgIC8vIHNlbmRTbXMocGhvbmVOdW1iZXIsIHNtc01lc3NhZ2UpO1xuICAgIGRlYnVnICs9IGBTZW5kIEZha2UgU01TIHRvICR7cGhvbmVOdW1iZXJ9IHdpdGggbWVzc2FnZTogJHtzbXNNZXNzYWdlfVxcbmA7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGRlYnVnICs9IGBFcnJvciBpbiBzZW5kU21zQWxlcnQ6ICR7ZXJyb3IubWVzc2FnZX1cXG5gOyBcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc2VuZFNtc0FsZXJ0OicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmV0dXJuU29sdXRpb25SZXNwb25zZTogUmV0dXJucyB0aGUgZm9ybWF0dGVkIHNvbHV0aW9uIGRvY3VtZW50IGFuZCBkZWJ1ZyBpbmZvcm1hdGlvbiBhcyB0aGUgQVBJIHJlc3BvbnNlXG4gICAgY29uc3QgcmV0dXJuU29sdXRpb25SZXNwb25zZSA9IGFzeW5jIChzb2x1dGlvbkRvY3VtZW50OiBzdHJpbmcsIGRlYnVnOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHtcbiAgICAgICAgICBtZXNzYWdlOiBzb2x1dGlvbkRvY3VtZW50LFxuICAgICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIEFQSSByZXNwb25zZVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBkZWJ1ZyArPSBgRXJyb3IgaW4gcmV0dXJuU29sdXRpb25SZXNwb25zZTogJHtlcnJvci5tZXNzYWdlfVxcbmA7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJldHVyblNvbHV0aW9uUmVzcG9uc2U6JywgZXJyb3IpO1xuXG4gICAgICAgIC8vIFJldHVybiBhbiBlcnJvciByZXNwb25zZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBnZW5lcmF0aW5nIHRoZSBzb2x1dGlvbiByZXNwb25zZS4nLFxuICAgICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTWFpbiBleGVjdXRpb24gZmxvd1xuICAgIGNvbnN0IHRhc2tEYXRhID0gYXdhaXQgbG9hZFRhc2tGcm9tRmlsZSh1c2VyUmVxdWVzdCk7XG4gICAgY29uc3QgeyB0cmFpblBhaXJzLCB0ZXN0UGFpcnMgfSA9IGF3YWl0IHBhcnNlVGFza0RhdGEodGFza0RhdGEpO1xuICAgIGNvbnN0IGluaXRpYWxSdWxlcyA9IGF3YWl0IGFuYWx5emVUcmFpblBhaXJzKHRyYWluUGFpcnMpO1xuICAgIGNvbnN0IHJlZmluZWRSdWxlcyA9IGF3YWl0IHJlZmluZVJ1bGVzKGluaXRpYWxSdWxlcywgdHJhaW5QYWlycyk7XG4gICAgY29uc3Qgc29sdXRpb25zID0gYXdhaXQgYXBwbHlSdWxlc1RvVGVzdFBhaXJzKHJlZmluZWRSdWxlcywgdGVzdFBhaXJzKTtcbiAgICBjb25zdCBzb2x1dGlvbkRvY3VtZW50ID0gYXdhaXQgZm9ybWF0U29sdXRpb25Eb2N1bWVudChzb2x1dGlvbnMsIHJlZmluZWRSdWxlcyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBtYXJrZG93biB0YWJsZXMgZm9yIGlucHV0IGFuZCBvdXRwdXQgZ3JpZHMgaW4gZWFjaCBzb2x1dGlvblxuICAgIGZvciAoY29uc3Qgc29sdXRpb24gb2Ygc29sdXRpb25zKSB7XG4gICAgICBjb25zdCBpbnB1dEdyaWRNYXJrZG93biA9IGF3YWl0IGdlbmVyYXRlR3JpZE1hcmtkb3duKHNvbHV0aW9uLmlucHV0R3JpZCk7XG4gICAgICBjb25zdCBvdXRwdXRHcmlkTWFya2Rvd24gPSBhd2FpdCBnZW5lcmF0ZUdyaWRNYXJrZG93bihzb2x1dGlvbi5vdXRwdXRHcmlkKTtcbiAgICAgIHNvbHV0aW9uLmlucHV0R3JpZE1hcmtkb3duID0gaW5wdXRHcmlkTWFya2Rvd247XG4gICAgICBzb2x1dGlvbi5vdXRwdXRHcmlkTWFya2Rvd24gPSBvdXRwdXRHcmlkTWFya2Rvd247XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBzb2x1dGlvbiBkb2N1bWVudCB3aXRoIHRoZSBncmlkIG1hcmtkb3duc1xuICAgIGxldCBzb2x1dGlvbkRvY3VtZW50V2l0aEdyaWRzID0gc29sdXRpb25Eb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IHNvbHV0aW9uIG9mIHNvbHV0aW9ucykge1xuICAgICAgc29sdXRpb25Eb2N1bWVudFdpdGhHcmlkcyA9IHNvbHV0aW9uRG9jdW1lbnRXaXRoR3JpZHMucmVwbGFjZShcbiAgICAgICAgYFtJbnB1dCBHcmlkIGZvciBUZXN0IFBhaXIgJHtzb2x1dGlvbi5wYWlyTnVtYmVyfV1gLFxuICAgICAgICBzb2x1dGlvbi5pbnB1dEdyaWRNYXJrZG93blxuICAgICAgKS5yZXBsYWNlKFxuICAgICAgICBgW091dHB1dCBHcmlkIGZvciBUZXN0IFBhaXIgJHtzb2x1dGlvbi5wYWlyTnVtYmVyfV1gLFxuICAgICAgICBzb2x1dGlvbi5vdXRwdXRHcmlkTWFya2Rvd24gIFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhd2FpdCBzZW5kU21zQWxlcnQocGhvbmVOdW1iZXIsIHNvbHV0aW9uRG9jdW1lbnRXaXRoR3JpZHMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmV0dXJuU29sdXRpb25SZXNwb25zZShzb2x1dGlvbkRvY3VtZW50V2l0aEdyaWRzLCBkZWJ1Zyk7XG5cbiAgICBjb25zdCBiZWF1dGlmdWxPcmdhbml6ZWRNYXJrZG93blJlcGx5ID0gYCR7cmVzcG9uc2UubWVzc2FnZX1cblxuIyMgRGVidWcgSW5mb3JtYXRpb25cbjxkZXRhaWxzPlxuPHN1bW1hcnk+Q2xpY2sgdG8gZXhwYW5kIGRlYnVnIGluZm9ybWF0aW9uPC9zdW1tYXJ5PlxuXG4ke3Jlc3BvbnNlLmRlYnVnfVxuXG48L2RldGFpbHM+XG4gICAgYDtcblxuICAgIGNvbnN0IHNtc1JlcGx5ID0gYFlvdXIgQVJDIFNvbHZlciBzb2x1dGlvbiBpcyByZWFkeSEgQ2hlY2sgeW91ciBlbWFpbCBvciBjaGF0LmhleWRhdGEub3JnIGZvciB0aGUgZnVsbCBzb2x1dGlvbiBkZXRhaWxzLmA7XG5cbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICBtZXNzYWdlOiBiZWF1dGlmdWxPcmdhbml6ZWRNYXJrZG93blJlcGx5LFxuICAgICAgZGVidWc6IGRlYnVnLFxuICAgICAgc21zUmVwbHk6IHNtc1JlcGx5XG4gICAgfSk7XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnN0IGVycm9yU21zUmVwbHkgPSBgU29ycnksIEkgY291bGRuJ3Qgc29sdmUgdGhlIEFSQyB0YXNrIHlvdSByZXF1ZXN0ZWQuIFNlZSBjaGF0LmhleWRhdGEub3JnIGZvciBkZXRhaWxzIG9yIHRyeSBhZ2FpbiB3aXRoIGEgZGlmZmVyZW50IGZpbGUuYDtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBBUkNTb2x2ZXI6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgZGVidWcgKz0gYEVycm9yIGluIEFSQ1NvbHZlcjogJHtlcnJvci5tZXNzYWdlfVxcbmA7XG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgbWVzc2FnZTogYFxuIyMgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcnVubmluZyB0aGUgQVJDIFNvbHZlciBza2lsbCDwn5ieIFxuU29ycnkhIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHByb2Nlc3NpbmcgdGhlIEFSQyB0YXNrIHlvdSByZXF1ZXN0ZWQuIEhlcmUgYXJlIHNvbWUgZGV0YWlscyBhYm91dCB0aGUgZXJyb3I6XG5cbjxkZXRhaWxzPlxuPHN1bW1hcnk+PGk+Q2xpY2sgaGVyZSBmb3IgbW9yZSB0ZWNobmljYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuLi48L2k+PC9zdW1tYXJ5PlxuXG5cXGBcXGBcXGBcbiR7ZXJyb3IubWVzc2FnZX1cblxcYFxcYFxcYFxuXG5cXGBcXGBcXGBcbiR7ZGVidWd9XG5cXGBcXGBcXGBcblxuPC9kZXRhaWxzPlxuXG4qKlN1Z2dlc3Rpb25zOioqXG4tIERvdWJsZSBjaGVjayB0aGUgZm9ybWF0IG9mIHRoZSB0YXNrIEpTT04gZmlsZSB5b3UgcHJvdmlkZWQuIEl0IHNob3VsZCBtYXRjaCB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZvciBBUkMgdGFza3MuXG4tIFRyeSBhIGRpZmZlcmVudCB0YXNrIGZpbGUsIHByZWZlcmFibHkgb25lIGZyb20gdGhlIHRyYWluaW5nIHNldCBmaXJzdCB0byB0ZXN0LlxuLSBJZiB0aGUgaXNzdWUgcGVyc2lzdHMsIHBsZWFzZSByZWFjaCBvdXQgb24gY2hhdC5oZXlkYXRhLm9yZyBmb3Igc3VwcG9ydC4gV2UnbGwgZG8gb3VyIGJlc3QgdG8gcmVzb2x2ZSBpdCFcblxuVGhhbmtzIGZvciB5b3VyIHBhdGllbmNlIGFuZCB1bmRlcnN0YW5kaW5nLiBMZXQncyBzb2x2ZSBzb21lIEFSQyB0YXNrcyEg8J+nqfCfkqpcbiAgICAgIGAsIFxuICAgICAgc21zUmVwbHk6IGVycm9yU21zUmVwbHksXG4gICAgICBkZWJ1ZzogZGVidWdcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiXSwibmFtZXMiOlsiZ3B0UmVxdWVzdCIsInJ1bkNvbW1hbmQiLCJpc1ZhbGlkVXJsIiwiaGFuZGxlciIsInJlcSIsInJlcyIsInVzZXJSZXF1ZXN0IiwicGhvbmVOdW1iZXIiLCJlbWFpbCIsIm1vZGVsIiwibG9jYXRpb24iLCJjdXJyZW50VXNlclRpbWUiLCJjbGlwYm9hcmRDb3B5IiwiYXJncyIsInJldHVyblR5cGUiLCJib3QiLCJib2R5IiwiZGF0YVNraWxsRGVmIiwiZmlsZU5hbWUiLCJkaXNwbGF5TmFtZSIsInJlY29tbWVuZGVkTW9kZWxzIiwiZW1vamkiLCJoZWFkZXJJbWFnZSIsImljb24iLCJkZXNjcmlwdGlvbiIsInJlbGlhYmlsaXR5IiwicmVsaWFiaWxpdHlSYXRpbyIsImtleXdvcmRzIiwiZmFjdENoZWNraW5nIiwiZXN0aW1hdGVkUnVuVGltZSIsInNvdGFFc3RpbWF0ZWRDb3N0IiwibWF4Q29uY3VycmVuY3kiLCJwcmVQcm9tcHQiLCJkZXBlbmRlbmNpZXMiLCJza2lsbENsYXNzIiwia25vd25Jc3N1ZXMiLCJyb2FkbWFwIiwid2Fsa3Rocm91Z2giLCJhdXRob3IiLCJhdXRob3JEVUlEIiwicGF5cGFsRW1haWwiLCJkb25hdGVMaW5rIiwic29jaWFsSGFuZGxlIiwicHJvbW9VcmwiLCJzdXBwb3J0VXJsIiwic2tpbGxEVUlEIiwic2tpbGxWZXJzaW9uIiwiZGF0YVZlcnNpb24iLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJqc29uIiwiZGVidWciLCJzb3VyY2VDb2RlIiwibG9hZFRhc2tGcm9tRmlsZSIsInRhc2tEYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwicmVxdWlyZSIsImVycm9yIiwibWVzc2FnZSIsImdpdGh1YlNlYXJjaFByb21wdCIsImdpdGh1YlNlYXJjaFJlc3VsdCIsInRhc2tGaWxlVXJsUmVnZXgiLCJ0YXNrRmlsZVVybE1hdGNoIiwiZGF0YSIsIm1hdGNoIiwidGFza0ZpbGVVcmwiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZVRhc2tEYXRhIiwiY29uc29sZSIsImxvZyIsInRyYWluUGFpcnMiLCJ0cmFpbiIsInRlc3RQYWlycyIsInRlc3QiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJhbmFseXplVHJhaW5QYWlycyIsImFuYWx5emVUcmFpblBhaXJzUHJvbXB0Iiwic3lzdGVtUHJvbXB0IiwicHJvbXB0IiwiaW5pdGlhbFJ1bGVzUmVzcG9uc2UiLCJpbml0aWFsUnVsZXMiLCJzcGxpdCIsIm1hcCIsInJ1bGUiLCJ0cmltIiwiZmlsdGVyIiwicmVmaW5lUnVsZXMiLCJyZWZpbmVkUnVsZXMiLCJpIiwicmVmaW5lUnVsZXNQcm9tcHQiLCJqb2luIiwicmVmaW5lbWVudFJlc3VsdCIsInJlZmluZWRSdWxlc01hdGNoIiwiYWxsVHJhaW5QYWlyc1NvbHZlZCIsInBhaXIiLCJpbnB1dCIsImV4cGVjdGVkT3V0cHV0Iiwib3V0cHV0IiwiYWN0dWFsT3V0cHV0IiwiYXBwbHlSdWxlcyIsInJ1bGVzIiwiYXBwbHlSdWxlc1RvVGVzdFBhaXJzIiwiYXBwbHlSdWxlc1Byb21wdCIsInNvbHV0aW9uc1Jlc3BvbnNlIiwic29sdXRpb25zTWF0Y2giLCJzb2x1dGlvbnNUZXh0Iiwic29sdXRpb25SZWdleCIsInNvbHV0aW9ucyIsImV4ZWMiLCJfIiwicGFpck51bWJlciIsIm91dHB1dEdyaWQiLCJleHBsYW5hdGlvbiIsInB1c2giLCJwYXJzZUludCIsInBhcnNlIiwiZm9ybWF0U29sdXRpb25Eb2N1bWVudCIsImZvcm1hdFByb21wdCIsInNvbHV0aW9uRG9jdW1lbnRSZXNwb25zZSIsImdlbmVyYXRlR3JpZE1hcmtkb3duIiwiZ3JpZCIsImdyaWRNYXJrZG93biIsImNvbCIsInJvdyIsImNlbGxWYWx1ZSIsInNlbmRTbXNBbGVydCIsInNvbHV0aW9uRG9jdW1lbnQiLCJzbXNQcm9tcHQiLCJzbXNNZXNzYWdlIiwicmV0dXJuU29sdXRpb25SZXNwb25zZSIsInJlc3BvbnNlQm9keSIsInNvbHV0aW9uIiwiaW5wdXRHcmlkTWFya2Rvd24iLCJpbnB1dEdyaWQiLCJvdXRwdXRHcmlkTWFya2Rvd24iLCJzb2x1dGlvbkRvY3VtZW50V2l0aEdyaWRzIiwicmVwbGFjZSIsImJlYXV0aWZ1bE9yZ2FuaXplZE1hcmtkb3duUmVwbHkiLCJzbXNSZXBseSIsImVycm9yU21zUmVwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/v1/skills/newSkill.ts\n");

/***/ }),

/***/ "(api)/./utils/gpt/gptUtils.ts":
/*!*******************************!*\
  !*** ./utils/gpt/gptUtils.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"activateDATA\": () => (/* binding */ activateDATA),\n/* harmony export */   \"gptRequest\": () => (/* binding */ gptRequest)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n// utils/gpt/gptUtils.ts\n\nconst BASE_URL = \"https://heydata.org\";\nasync function gptRequest(model, temperature, content, prompt, phoneNumber, email, maxTokens, imageUrl, detail, bannedWords) {\n    try {\n        //console.log('Sending GPT Request to DATA with these variables: ', model, temperature, content, prompt, phoneNumber, email, maxTokens, imageUrl, detail, bannedWords);\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(`${BASE_URL}/api/gptRequests`, {\n            model,\n            temperature,\n            content,\n            prompt,\n            phoneNumber,\n            email,\n            maxTokens,\n            imageUrl,\n            detail,\n            bannedWords\n        });\n        //console.log(`Received GPT Response from DATA:`, response.data);\n        return response.data.gptOutput;\n    } catch (error) {\n        console.error(\"Error in gptRequest:\", error);\n        throw error;\n    }\n}\nasync function activateDATA(userRequest, phoneNumber, email, location, systemPrompt, subject, commandsDisabled, model, outputLength, callType, replyType, stop, bot, userName, time) {\n    try {\n        console.log(\"Sending activateDATA request to DATA with these variables: \", userRequest, phoneNumber, email, location, systemPrompt, subject, commandsDisabled, model, outputLength, callType, replyType, stop, bot, userName, time);\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(`${BASE_URL}/api/v1/coreDATA`, {\n            userRequest,\n            phoneNumber,\n            email,\n            location,\n            systemPrompt,\n            subject,\n            commandsDisabled,\n            model,\n            outputLength,\n            callType,\n            replyType,\n            stop,\n            bot,\n            userName,\n            time\n        });\n        console.log(`Received activateDATA response from DATA:`, response.data);\n        return response;\n    } catch (error) {\n        console.error(\"Error in activateDATA:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9ncHQvZ3B0VXRpbHMudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHdCQUF3QjtBQUNFO0FBRTFCLE1BQU1DLFFBQVEsR0FBRyxxQkFBcUI7QUFFL0IsZUFBZUMsVUFBVSxDQUFDQyxLQUFhLEVBQUVDLFdBQW1CLEVBQUVDLE9BQWUsRUFBRUMsTUFBYyxFQUFFQyxXQUFtQixFQUFFQyxLQUFhLEVBQUVDLFNBQWlCLEVBQUVDLFFBQWlCLEVBQUVDLE1BQWUsRUFBRUMsV0FBb0IsRUFBRTtJQUN0TixJQUFJO1FBQ0QsdUtBQXVLO1FBQ3ZLLE1BQU1DLFFBQVEsR0FBRyxNQUFNYixpREFBVSxDQUFDLENBQUMsRUFBRUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDaEVFLEtBQUs7WUFDTEMsV0FBVztZQUNYQyxPQUFPO1lBQ1BDLE1BQU07WUFDTkMsV0FBVztZQUNYQyxLQUFLO1lBQ0xDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxNQUFNO1lBQ05DLFdBQVc7U0FDWixDQUFDO1FBQ0YsaUVBQWlFO1FBQ2pFLE9BQU9DLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDQyxTQUFTLENBQUM7SUFDakMsRUFBRSxPQUFPQyxLQUFLLEVBQUU7UUFDZEMsT0FBTyxDQUFDRCxLQUFLLENBQUMsc0JBQXNCLEVBQUVBLEtBQUssQ0FBQyxDQUFDO1FBQzdDLE1BQU1BLEtBQUssQ0FBQztJQUNkLENBQUM7QUFDRixDQUFDO0FBRU0sZUFBZUUsWUFBWSxDQUNqQ0MsV0FBbUIsRUFDbkJiLFdBQW1CLEVBQ25CQyxLQUFhLEVBQ2JhLFFBQWlCLEVBQ2pCQyxZQUFxQixFQUNyQkMsT0FBZ0IsRUFDaEJDLGdCQUFtQyxFQUNuQ3JCLEtBQWMsRUFDZHNCLFlBQXFCLEVBQ3JCQyxRQUFpQixFQUNqQkMsU0FBa0IsRUFDbEJDLElBQWEsRUFDYkMsR0FBWSxFQUNaQyxRQUFpQixFQUNqQkMsSUFBYSxFQUNaO0lBQ0QsSUFBSTtRQUNGYixPQUFPLENBQUNjLEdBQUcsQ0FBQyw2REFBNkQsRUFBRVosV0FBVyxFQUFFYixXQUFXLEVBQUVDLEtBQUssRUFBRWEsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLE9BQU8sRUFBRUMsZ0JBQWdCLEVBQUVyQixLQUFLLEVBQUVzQixZQUFZLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLENBQUMsQ0FBQztRQUNwTyxNQUFNbEIsUUFBUSxHQUFHLE1BQU1iLGlEQUFVLENBQUMsQ0FBQyxFQUFFQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUMvRG1CLFdBQVc7WUFDWGIsV0FBVztZQUNYQyxLQUFLO1lBQ0xhLFFBQVE7WUFDUkMsWUFBWTtZQUNaQyxPQUFPO1lBQ1BDLGdCQUFnQjtZQUNoQnJCLEtBQUs7WUFDTHNCLFlBQVk7WUFDWkMsUUFBUTtZQUNSQyxTQUFTO1lBQ1RDLElBQUk7WUFDSkMsR0FBRztZQUNIQyxRQUFRO1lBQ1JDLElBQUk7U0FDTCxDQUFDO1FBQ0ZiLE9BQU8sQ0FBQ2MsR0FBRyxDQUFDLENBQUMseUNBQXlDLENBQUMsRUFBRW5CLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDLENBQUM7UUFDeEUsT0FBT0YsUUFBUSxDQUFDO0lBQ2xCLEVBQUUsT0FBT0ksS0FBSyxFQUFFO1FBQ2RDLE9BQU8sQ0FBQ0QsS0FBSyxDQUFDLHdCQUF3QixFQUFFQSxLQUFLLENBQUMsQ0FBQztRQUMvQyxNQUFNQSxLQUFLLENBQUM7SUFDZCxDQUFDO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3V0aWxzL2dwdC9ncHRVdGlscy50cz82MjZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxzL2dwdC9ncHRVdGlscy50c1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuY29uc3QgQkFTRV9VUkwgPSAnaHR0cHM6Ly9oZXlkYXRhLm9yZyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBncHRSZXF1ZXN0KG1vZGVsOiBzdHJpbmcsIHRlbXBlcmF0dXJlOiBudW1iZXIsIGNvbnRlbnQ6IHN0cmluZywgcHJvbXB0OiBzdHJpbmcsIHBob25lTnVtYmVyOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIG1heFRva2VuczogbnVtYmVyLCBpbWFnZVVybD86IHN0cmluZywgZGV0YWlsPzogc3RyaW5nLCBiYW5uZWRXb3Jkcz86IHN0cmluZykge1xuIHRyeSB7XG4gICAgLy9jb25zb2xlLmxvZygnU2VuZGluZyBHUFQgUmVxdWVzdCB0byBEQVRBIHdpdGggdGhlc2UgdmFyaWFibGVzOiAnLCBtb2RlbCwgdGVtcGVyYXR1cmUsIGNvbnRlbnQsIHByb21wdCwgcGhvbmVOdW1iZXIsIGVtYWlsLCBtYXhUb2tlbnMsIGltYWdlVXJsLCBkZXRhaWwsIGJhbm5lZFdvcmRzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QkFTRV9VUkx9L2FwaS9ncHRSZXF1ZXN0c2AsIHtcbiAgICAgbW9kZWwsXG4gICAgIHRlbXBlcmF0dXJlLFxuICAgICBjb250ZW50LFxuICAgICBwcm9tcHQsXG4gICAgIHBob25lTnVtYmVyLFxuICAgICBlbWFpbCxcbiAgICAgbWF4VG9rZW5zLFxuICAgICBpbWFnZVVybCxcbiAgICAgZGV0YWlsLFxuICAgICBiYW5uZWRXb3JkcyxcbiAgIH0pO1xuICAgLy9jb25zb2xlLmxvZyhgUmVjZWl2ZWQgR1BUIFJlc3BvbnNlIGZyb20gREFUQTpgLCByZXNwb25zZS5kYXRhKTtcbiAgIHJldHVybiByZXNwb25zZS5kYXRhLmdwdE91dHB1dDtcbiB9IGNhdGNoIChlcnJvcikge1xuICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ3B0UmVxdWVzdDonLCBlcnJvcik7XG4gICB0aHJvdyBlcnJvcjtcbiB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhY3RpdmF0ZURBVEEoXG4gdXNlclJlcXVlc3Q6IHN0cmluZyxcbiBwaG9uZU51bWJlcjogc3RyaW5nLFxuIGVtYWlsOiBzdHJpbmcsXG4gbG9jYXRpb24/OiBzdHJpbmcsXG4gc3lzdGVtUHJvbXB0Pzogc3RyaW5nLFxuIHN1YmplY3Q/OiBzdHJpbmcsXG4gY29tbWFuZHNEaXNhYmxlZD86IGJvb2xlYW4gfCBzdHJpbmcsXG4gbW9kZWw/OiBzdHJpbmcsXG4gb3V0cHV0TGVuZ3RoPzogbnVtYmVyLFxuIGNhbGxUeXBlPzogc3RyaW5nLFxuIHJlcGx5VHlwZT86IHN0cmluZyxcbiBzdG9wPzogc3RyaW5nLFxuIGJvdD86IHN0cmluZyxcbiB1c2VyTmFtZT86IHN0cmluZyxcbiB0aW1lPzogc3RyaW5nXG4pIHtcbiB0cnkge1xuICAgY29uc29sZS5sb2coJ1NlbmRpbmcgYWN0aXZhdGVEQVRBIHJlcXVlc3QgdG8gREFUQSB3aXRoIHRoZXNlIHZhcmlhYmxlczogJywgdXNlclJlcXVlc3QsIHBob25lTnVtYmVyLCBlbWFpbCwgbG9jYXRpb24sIHN5c3RlbVByb21wdCwgc3ViamVjdCwgY29tbWFuZHNEaXNhYmxlZCwgbW9kZWwsIG91dHB1dExlbmd0aCwgY2FsbFR5cGUsIHJlcGx5VHlwZSwgc3RvcCwgYm90LCB1c2VyTmFtZSwgdGltZSk7XG4gICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QkFTRV9VUkx9L2FwaS92MS9jb3JlREFUQWAsIHtcbiAgICAgdXNlclJlcXVlc3QsXG4gICAgIHBob25lTnVtYmVyLFxuICAgICBlbWFpbCxcbiAgICAgbG9jYXRpb24sXG4gICAgIHN5c3RlbVByb21wdCxcbiAgICAgc3ViamVjdCxcbiAgICAgY29tbWFuZHNEaXNhYmxlZCxcbiAgICAgbW9kZWwsXG4gICAgIG91dHB1dExlbmd0aCxcbiAgICAgY2FsbFR5cGUsXG4gICAgIHJlcGx5VHlwZSxcbiAgICAgc3RvcCxcbiAgICAgYm90LFxuICAgICB1c2VyTmFtZSxcbiAgICAgdGltZSxcbiAgIH0pO1xuICAgY29uc29sZS5sb2coYFJlY2VpdmVkIGFjdGl2YXRlREFUQSByZXNwb25zZSBmcm9tIERBVEE6YCwgcmVzcG9uc2UuZGF0YSk7XG4gICByZXR1cm4gcmVzcG9uc2U7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGFjdGl2YXRlREFUQTonLCBlcnJvcik7XG4gICB0aHJvdyBlcnJvcjtcbiB9XG59Il0sIm5hbWVzIjpbImF4aW9zIiwiQkFTRV9VUkwiLCJncHRSZXF1ZXN0IiwibW9kZWwiLCJ0ZW1wZXJhdHVyZSIsImNvbnRlbnQiLCJwcm9tcHQiLCJwaG9uZU51bWJlciIsImVtYWlsIiwibWF4VG9rZW5zIiwiaW1hZ2VVcmwiLCJkZXRhaWwiLCJiYW5uZWRXb3JkcyIsInJlc3BvbnNlIiwicG9zdCIsImRhdGEiLCJncHRPdXRwdXQiLCJlcnJvciIsImNvbnNvbGUiLCJhY3RpdmF0ZURBVEEiLCJ1c2VyUmVxdWVzdCIsImxvY2F0aW9uIiwic3lzdGVtUHJvbXB0Iiwic3ViamVjdCIsImNvbW1hbmRzRGlzYWJsZWQiLCJvdXRwdXRMZW5ndGgiLCJjYWxsVHlwZSIsInJlcGx5VHlwZSIsInN0b3AiLCJib3QiLCJ1c2VyTmFtZSIsInRpbWUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./utils/gpt/gptUtils.ts\n");

/***/ }),

/***/ "(api)/./utils/notion/notionUtils.ts":
/*!*************************************!*\
  !*** ./utils/notion/notionUtils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compressImage\": () => (/* binding */ compressImage),\n/* harmony export */   \"fetchValidImageUrl\": () => (/* binding */ fetchValidImageUrl),\n/* harmony export */   \"isValidUrl\": () => (/* binding */ isValidUrl),\n/* harmony export */   \"uploadImageToImgur\": () => (/* binding */ uploadImageToImgur)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n// utils/notion/notionUtils.ts\n\nconst BASE_URL = \"https://heydata.org\";\nconst fetchValidImageUrl = async (imagePrompt, phoneNumber, email, size = \"1024x1792\", retries = 3, delayMs = 5000)=>{\n    try {\n        console.log(\"Fetching image URL from DATA...\", imagePrompt, phoneNumber, email, size, retries, delayMs);\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(BASE_URL, {\n            action: \"fetchValidImageUrl\",\n            data: {\n                imagePrompt,\n                phoneNumber,\n                email,\n                size,\n                retries,\n                delayMs\n            }\n        });\n        console.log(\"Received image URL from DATA:\", response.data);\n        return response.data.imageUrl;\n    } catch (error) {\n        console.error(\"Error fetching valid image URL:\", error);\n        return \"\";\n    }\n};\nconst isValidUrl = async (url)=>{\n    try {\n        console.log(\"Checking if URL is valid with DATA...\", url);\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(BASE_URL, {\n            action: \"isValidUrl\",\n            data: {\n                url\n            }\n        });\n        console.log(\"Received isValidUrl response from DATA:\", response.data);\n        return response.data.isValid;\n    } catch (error) {\n        console.error(\"Error checking URL validity:\", error);\n        return false;\n    }\n};\nconst compressImage = async (input)=>{\n    try {\n        console.log(\"Compressing image with DATA...\", input);\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(BASE_URL, {\n            action: \"compressImage\",\n            data: {\n                input\n            }\n        });\n        console.log(\"Received compressed image from DATA:\", response.data);\n        return Buffer.from(response.data.compressedImageBuffer.data);\n    } catch (error) {\n        console.error(\"Error compressing image:\", error);\n        return null;\n    }\n};\nconst uploadImageToImgur = async (compressedImageBuffer)=>{\n    try {\n        console.log(\"Uploading image to Imgur with DATA...\", compressedImageBuffer);\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(BASE_URL, {\n            action: \"uploadImageToImgur\",\n            data: {\n                buffer: compressedImageBuffer\n            }\n        });\n        console.log(response.data);\n        return response.data.imgurUrl;\n    } catch (error) {\n        console.error(\"Error uploading image to Imgur:\", error);\n        return \"\";\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDQyxHQUFHLENBQUMsdUNBQXVDLEVBQUVjLHFCQUFxQixDQUFDLENBQUM7UUFDNUUsTUFBTWIsUUFBUSxHQUFHLE1BQU1YLGlEQUFVLENBQUNDLFFBQVEsRUFBRTtZQUMxQ1ksTUFBTSxFQUFFLG9CQUFvQjtZQUM1QkMsSUFBSSxFQUFFO2dCQUFFWSxNQUFNLEVBQUVGLHFCQUFxQjthQUFFO1NBQ3hDLENBQUM7UUFDSGYsT0FBTyxDQUFDQyxHQUFHLENBQUNDLFFBQVEsQ0FBQ0csSUFBSSxDQUFDLENBQUM7UUFDMUIsT0FBT0gsUUFBUSxDQUFDRyxJQUFJLENBQUNhLFFBQVEsQ0FBQztJQUNoQyxFQUFFLE9BQU9YLEtBQUssRUFBRTtRQUNkUCxPQUFPLENBQUNPLEtBQUssQ0FBQyxpQ0FBaUMsRUFBRUEsS0FBSyxDQUFDLENBQUM7UUFDeEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0FBQ0gsQ0FBQztBQUU0RSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3V0aWxzL25vdGlvbi9ub3Rpb25VdGlscy50cz83ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHV0aWxzL25vdGlvbi9ub3Rpb25VdGlscy50c1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuY29uc3QgQkFTRV9VUkwgPSAnaHR0cHM6Ly9oZXlkYXRhLm9yZyc7XG5cbmNvbnN0IGZldGNoVmFsaWRJbWFnZVVybCA9IGFzeW5jIChcbiAgaW1hZ2VQcm9tcHQ6IHN0cmluZyxcbiAgcGhvbmVOdW1iZXI6IHN0cmluZyxcbiAgZW1haWw6IHN0cmluZyxcbiAgc2l6ZTogc3RyaW5nID0gJzEwMjR4MTc5MicsXG4gIHJldHJpZXM6IG51bWJlciA9IDMsXG4gIGRlbGF5TXM6IG51bWJlciA9IDUwMDBcbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIHRyeSB7XG4gICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgaW1hZ2UgVVJMIGZyb20gREFUQS4uLicsIGltYWdlUHJvbXB0LCBwaG9uZU51bWJlciwgZW1haWwsIHNpemUsIHJldHJpZXMsIGRlbGF5TXMpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChCQVNFX1VSTCwge1xuICAgICAgYWN0aW9uOiAnZmV0Y2hWYWxpZEltYWdlVXJsJyxcbiAgICAgIGRhdGE6IHsgaW1hZ2VQcm9tcHQsIHBob25lTnVtYmVyLCBlbWFpbCwgc2l6ZSwgcmV0cmllcywgZGVsYXlNcyB9LFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBpbWFnZSBVUkwgZnJvbSBEQVRBOicsIHJlc3BvbnNlLmRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmltYWdlVXJsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHZhbGlkIGltYWdlIFVSTDonLCBlcnJvcik7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5jb25zdCBpc1ZhbGlkVXJsID0gYXN5bmMgKHVybDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGlmIFVSTCBpcyB2YWxpZCB3aXRoIERBVEEuLi4nLCB1cmwpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChCQVNFX1VSTCwge1xuICAgICAgYWN0aW9uOiAnaXNWYWxpZFVybCcsXG4gICAgICBkYXRhOiB7IHVybCB9LFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBpc1ZhbGlkVXJsIHJlc3BvbnNlIGZyb20gREFUQTonLCByZXNwb25zZS5kYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pc1ZhbGlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIFVSTCB2YWxpZGl0eTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBjb21wcmVzc0ltYWdlID0gYXN5bmMgKGlucHV0OiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlciB8IG51bGw+ID0+IHtcbiAgdHJ5IHtcbiAgIGNvbnNvbGUubG9nKCdDb21wcmVzc2luZyBpbWFnZSB3aXRoIERBVEEuLi4nLCBpbnB1dCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KEJBU0VfVVJMLCB7XG4gICAgICBhY3Rpb246ICdjb21wcmVzc0ltYWdlJyxcbiAgICAgIGRhdGE6IHsgaW5wdXQgfSxcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgY29tcHJlc3NlZCBpbWFnZSBmcm9tIERBVEE6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3BvbnNlLmRhdGEuY29tcHJlc3NlZEltYWdlQnVmZmVyLmRhdGEpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXByZXNzaW5nIGltYWdlOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuY29uc3QgdXBsb2FkSW1hZ2VUb0ltZ3VyID0gYXN5bmMgKGNvbXByZXNzZWRJbWFnZUJ1ZmZlcjogQnVmZmVyKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnVXBsb2FkaW5nIGltYWdlIHRvIEltZ3VyIHdpdGggREFUQS4uLicsIGNvbXByZXNzZWRJbWFnZUJ1ZmZlcik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KEJBU0VfVVJMLCB7XG4gICAgICBhY3Rpb246ICd1cGxvYWRJbWFnZVRvSW1ndXInLFxuICAgICAgZGF0YTogeyBidWZmZXI6IGNvbXByZXNzZWRJbWFnZUJ1ZmZlciB9LFxuICAgIH0pO1xuICAgY29uc29sZS5sb2cocmVzcG9uc2UuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaW1ndXJVcmw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBsb2FkaW5nIGltYWdlIHRvIEltZ3VyOicsIGVycm9yKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGZldGNoVmFsaWRJbWFnZVVybCwgaXNWYWxpZFVybCwgY29tcHJlc3NJbWFnZSwgdXBsb2FkSW1hZ2VUb0ltZ3VyIH07Il0sIm5hbWVzIjpbImF4aW9zIiwiQkFTRV9VUkwiLCJmZXRjaFZhbGlkSW1hZ2VVcmwiLCJpbWFnZVByb21wdCIsInBob25lTnVtYmVyIiwiZW1haWwiLCJzaXplIiwicmV0cmllcyIsImRlbGF5TXMiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJwb3N0IiwiYWN0aW9uIiwiZGF0YSIsImltYWdlVXJsIiwiZXJyb3IiLCJpc1ZhbGlkVXJsIiwidXJsIiwiaXNWYWxpZCIsImNvbXByZXNzSW1hZ2UiLCJpbnB1dCIsIkJ1ZmZlciIsImZyb20iLCJjb21wcmVzc2VkSW1hZ2VCdWZmZXIiLCJ1cGxvYWRJbWFnZVRvSW1ndXIiLCJidWZmZXIiLCJpbWd1clVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/notion/notionUtils.ts\n");

/***/ }),

/***/ "(api)/./utils/skills/commandUtil.ts":
/*!*************************************!*\
  !*** ./utils/skills/commandUtil.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"runCommand\": () => (/* binding */ runCommand)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n// utils/skills/commandUtil.ts\n\nconst BASE_URL = \"https://heydata.org\";\nasync function runCommand(commandFileName, userRequest, phoneNumber, email, model, location, currentUserTime, clipboardCopy, args, returnType, bot) {\n    console.log(\"Sending runCommand request to DATA: \", commandFileName, userRequest, phoneNumber, email, model, location, currentUserTime);\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(`${BASE_URL}/api/v1/skills/${commandFileName}`, {\n            userRequest,\n            phoneNumber,\n            email,\n            model,\n            location,\n            currentUserTime,\n            clipboardCopy,\n            args,\n            returnType,\n            bot\n        });\n        console.log(`Received runCommand ${commandFileName} response from DATA:`, response.data);\n        return response;\n    } catch (error) {\n        console.error(\"Error in runCommand:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9za2lsbHMvY29tbWFuZFV0aWwudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsOEJBQThCO0FBQ0o7QUFFMUIsTUFBTUMsUUFBUSxHQUFHLHFCQUFxQjtBQUUvQixlQUFlQyxVQUFVLENBQUNDLGVBQXVCLEVBQUVDLFdBQW1CLEVBQUVDLFdBQW9CLEVBQUVDLEtBQWMsRUFBRUMsS0FBYyxFQUFFQyxRQUFpQixFQUFFQyxlQUF3QixFQUFFQyxhQUFzQixFQUFFQyxJQUFVLEVBQUVDLFVBQW1CLEVBQUVDLEdBQVksRUFBRTtJQUN4UEMsT0FBTyxDQUFDQyxHQUFHLENBQUMsc0NBQXNDLEVBQUVaLGVBQWUsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLGVBQWUsQ0FBQyxDQUFDO0lBQ3hJLElBQUk7UUFDRixNQUFNTyxRQUFRLEdBQUcsTUFBTWhCLGlEQUFVLENBQUMsQ0FBQyxFQUFFQyxRQUFRLENBQUMsZUFBZSxFQUFFRSxlQUFlLENBQUMsQ0FBQyxFQUFFO1lBQ2hGQyxXQUFXO1lBQ1hDLFdBQVc7WUFDWEMsS0FBSztZQUNMQyxLQUFLO1lBQ0xDLFFBQVE7WUFDUkMsZUFBZTtZQUNmQyxhQUFhO1lBQ2JDLElBQUk7WUFDSkMsVUFBVTtZQUNWQyxHQUFHO1NBQ0osQ0FBQztRQUNGQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFWixlQUFlLENBQUMsb0JBQW9CLENBQUMsRUFBRWEsUUFBUSxDQUFDRSxJQUFJLENBQUMsQ0FBQztRQUN6RixPQUFPRixRQUFRLENBQUM7SUFDbEIsRUFBRSxPQUFPRyxLQUFLLEVBQUU7UUFDZEwsT0FBTyxDQUFDSyxLQUFLLENBQUMsc0JBQXNCLEVBQUVBLEtBQUssQ0FBQyxDQUFDO1FBQzdDLE1BQU1BLEtBQUssQ0FBQztJQUNkLENBQUM7QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdXRpbHMvc2tpbGxzL2NvbW1hbmRVdGlsLnRzPzc0NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdXRpbHMvc2tpbGxzL2NvbW1hbmRVdGlsLnRzXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG5jb25zdCBCQVNFX1VSTCA9ICdodHRwczovL2hleWRhdGEub3JnJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbW1hbmQoY29tbWFuZEZpbGVOYW1lOiBzdHJpbmcsIHVzZXJSZXF1ZXN0OiBzdHJpbmcsIHBob25lTnVtYmVyPzogc3RyaW5nLCBlbWFpbD86IHN0cmluZywgbW9kZWw/OiBzdHJpbmcsIGxvY2F0aW9uPzogc3RyaW5nLCBjdXJyZW50VXNlclRpbWU/OiBzdHJpbmcsIGNsaXBib2FyZENvcHk/OiBzdHJpbmcsIGFyZ3M/OiBhbnksIHJldHVyblR5cGU/OiBzdHJpbmcsIGJvdD86IHN0cmluZykge1xuIGNvbnNvbGUubG9nKCdTZW5kaW5nIHJ1bkNvbW1hbmQgcmVxdWVzdCB0byBEQVRBOiAnLCBjb21tYW5kRmlsZU5hbWUsIHVzZXJSZXF1ZXN0LCBwaG9uZU51bWJlciwgZW1haWwsIG1vZGVsLCBsb2NhdGlvbiwgY3VycmVudFVzZXJUaW1lKTtcbiB0cnkge1xuICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke0JBU0VfVVJMfS9hcGkvdjEvc2tpbGxzLyR7Y29tbWFuZEZpbGVOYW1lfWAsIHtcbiAgICAgdXNlclJlcXVlc3QsXG4gICAgIHBob25lTnVtYmVyLFxuICAgICBlbWFpbCxcbiAgICAgbW9kZWwsXG4gICAgIGxvY2F0aW9uLFxuICAgICBjdXJyZW50VXNlclRpbWUsXG4gICAgIGNsaXBib2FyZENvcHksXG4gICAgIGFyZ3MsXG4gICAgIHJldHVyblR5cGUsXG4gICAgIGJvdCxcbiAgIH0pO1xuICAgY29uc29sZS5sb2coYFJlY2VpdmVkIHJ1bkNvbW1hbmQgJHtjb21tYW5kRmlsZU5hbWV9IHJlc3BvbnNlIGZyb20gREFUQTpgLCByZXNwb25zZS5kYXRhKTtcbiAgIHJldHVybiByZXNwb25zZTtcbiB9IGNhdGNoIChlcnJvcikge1xuICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcnVuQ29tbWFuZDonLCBlcnJvcik7XG4gICB0aHJvdyBlcnJvcjtcbiB9XG59Il0sIm5hbWVzIjpbImF4aW9zIiwiQkFTRV9VUkwiLCJydW5Db21tYW5kIiwiY29tbWFuZEZpbGVOYW1lIiwidXNlclJlcXVlc3QiLCJwaG9uZU51bWJlciIsImVtYWlsIiwibW9kZWwiLCJsb2NhdGlvbiIsImN1cnJlbnRVc2VyVGltZSIsImNsaXBib2FyZENvcHkiLCJhcmdzIiwicmV0dXJuVHlwZSIsImJvdCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsInBvc3QiLCJkYXRhIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./utils/skills/commandUtil.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/v1/skills/newSkill.ts"));
module.exports = __webpack_exports__;

})();